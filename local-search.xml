<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python: 装饰器</title>
    <link href="/4Cc3.github.io/2024/05/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/4Cc3.github.io/2024/05/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>Python装饰器起到一个在函数前加点东西的作用  </p><p><img src="/4Cc3.github.io/images/pasted-83.png" alt="upload successful">  </p><p>这是最开始的函数, 然后我现在希望实现下面这个业务模式  </p><ul><li>当执行一个函数时, 我希望它先打印”666”, 然后再继续执行后面的函数</li></ul><p>这里的实现过程就很有意思了, 如果只有一个func1还好说, 但是假如有func2呢, 有func3呢, 有func100呢? 总不能把这些函数全部重新写一遍 ,这样就很浪费时间, 并且搞不好还会出错, 所以就需要一个类似装饰器的东西来解决这个问题  </p><p>从上层到下层来看,装饰器就是这样的:</p><p><img src="/4Cc3.github.io/images/pasted-84.png" alt="装饰器执行流程图">  </p><p>那么现在可以来看装饰器的原理了  </p><p><img src="/4Cc3.github.io/images/pasted-85.png" alt="装饰器原理">  </p><p>上图代码就是一个实现装饰器的过程, 装饰器函数接收一个函数, 然后新合成一个函数, 这个新合成的函数就是先执行打印666, 然后再把函数控制权转交出去, 这里第10行的部分其实就是获取这个新合成的函数的过程  </p><p>当然这么写肯定太捞了, 所以要换一种写法  </p><p><img src="/4Cc3.github.io/images/pasted-86.png" alt="python风格的写法">   </p><p>这里使用@加函数名即可, 其本质和上面的语句没有区别, 就是<code>func = zhuangshiqi(func)</code>, 这里使用@装饰器写法时, 会默认把@zhuangshiqi后面跟着的函数作为参数传递给zhuangshiqi这个函数, 所以如果定义装饰器函数的时候不给它指定参数会报错  </p><p><img src="/4Cc3.github.io/images/pasted-87.png" alt="upload successful">  </p><p>当然, 装饰器比较灵活, 这里还有带参数的装饰器可以用<br><img src="/4Cc3.github.io/images/pasted-88.png" alt="带参数的装饰器"><br>这里的原理其实是, 先把老八这个参数传递给decorator中的laotie, 然后这个decorator函数返回了一个zhuangshiqi函数, 这个装饰器函数又需要接收一个func参数, 然后来返回一个合成过的函数出来, 也就是说这里func拿到的其实是包装了两层后的func, 可能比较绕, 反正用的时候多试试就好了</p><p><img src="/4Cc3.github.io/images/pasted-89.png" alt="老八吃粑粑">  </p><p>像这样传递多个参数也是可以的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows下的保护模式</title>
    <link href="/4Cc3.github.io/2024/05/26/Windows%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/4Cc3.github.io/2024/05/26/Windows%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>任务就是指线程或者进程, 我们可以把保护机制划分为任务间的保护和任务内的保护</p><h2 id="任务间的保护"><a href="#任务间的保护" class="headerlink" title="任务间的保护"></a>任务间的保护</h2><p>在Win32版本下, 每个任务都被赋予4GB的虚拟内存空间,  可用地址为0~0XFFFFFFFF, 这里的意思就是说在这个虚拟的内存空间中可以存放任务的代码和数据等信息, 当这个任务实际被使用时, 看物理地址哪有空往哪放, 这也是虚拟的含义。  </p><p>当有了虚拟地址后，就会发现我们无法更改另一个程序的内存，只能更改本程序内存空间内的地址（也就是4GB的空间，0~0XFFFFFFFF）这样就防止在程序内修改其它程序的数据了</p><h2 id="任务内的保护"><a href="#任务内的保护" class="headerlink" title="任务内的保护"></a>任务内的保护</h2><p>任务内的保护是指，windows操作系统的代码和数据通常被映射到每个进程的高2GB的空间中，这就意味着操作系统的空间是可以被程序修改的，所以需要任务内的保护。为了保护操作系统的代码，程序通常被赋予特权值，地特权的代码不能访问和执行高特权的代码，这就防止了用户自己编写的代码访问操作系统的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">*(<span class="hljs-type">int</span>*) <span class="hljs-number">0xA0808080</span>=<span class="hljs-number">0x22</span>;<br></code></pre></td></tr></table></figure><p>像上述语句就会触发系统的检测机制,从而产生报错</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows下的分页机制</title>
    <link href="/4Cc3.github.io/2024/05/19/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6/"/>
    <url>/4Cc3.github.io/2024/05/19/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>本节参考《软件调试》卷一 2.7节  </p><p>操作系统在创建进程时， 就会为这个进程创建页表，页表是进程空间的物理基础</p><h2 id="32位经典分页"><a href="#32位经典分页" class="headerlink" title="32位经典分页"></a>32位经典分页</h2><p>  此处的经典是指没有开启PAE的分页模式，在该模式下，页表结构分为两级，第一级称为页目录表（Page Driectory），第二级称为页表（Page Table）。<br>  PD是一个存放页目录表项（Page Directory Entry） 的线性表，<em>每个PD占4KB</em>的内存， <em>每个PDE占32bit</em>， 所以一个PD最多可以有1024个PDE。</p><p><img src="/4Cc3.github.io/images/pasted-72.png" alt="页表与页目录表的关系"></p><p> PDE可以用于指向下一个PD，格式如下   </p><p><img src="/4Cc3.github.io/images/pasted-68.png" alt="指向PT的PDE的格式">  </p><p>当然也可以用于指向一个4MB的大内存页  </p><p><img src="/4Cc3.github.io/images/pasted-69.png" alt="指向4MB内存页的PDE的格式">  </p><p>而页表(Page Table)是用来存放页表表项(Page Table Entry)的线性表, 每个PT占4KB, 每个PTE占32bit, PTE的具体格式如下  </p><p><img src="/4Cc3.github.io/images/pasted-71.png" alt="PTE格式">  </p><p>现在来看CPU是如何将一个32bit的线性地址翻译为32bit的物理地址的  </p><ol><li><p>通过CR3寄存器定位到PD的起始地址,取该线性地址的高10bit作为索引选取PDE  </p></li><li><p>判断PDE的 PS位, 如果为1, 代表这个PDE指向一个4MB的大内存页, PDE的高10bit便是4MB内存页的基地址的高10位, 该线性地址的低22bit便是页内偏移, 将二者结合到一起就是物理地址了。如果PS为0，那么根据PDE中高20位定位到PT  </p></li><li><p>取该线性地址的12bit到21bit作为索引选取PT的一个表项，也就是PTE。  </p></li><li><p>取出PTE的高20位</p></li><li><p>取该线性地址的低12bit作为页内偏移与上一步的地址相加便能得到物理地址</p></li></ol><p>现在以软件调试中给出的实验材料进行实验  sdbgvola\dumps\xpsp3nop  </p><p><img src="/4Cc3.github.io/images/pasted-73.png" alt="upload successful">  </p><p>以这里的f8c2e04d为例, 该地址为线性地址  </p><p><img src="/4Cc3.github.io/images/pasted-74.png" alt="upload successful">  </p><p>转化为二进制后长这样  </p><p><img src="/4Cc3.github.io/images/pasted-75.png" alt="upload successful">  </p><p>然后把高十位的值计算出来, 为PDE的索引  </p><p><img src="/4Cc3.github.io/images/pasted-76.png" alt="upload successful">  </p><p>把中间十位算出来 为PT的索引</p><p>最后低十位的是04d 是页内偏移  </p><p><img src="/4Cc3.github.io/images/pasted-77.png" alt="upload successful"></p><p>然后可以看cr3这个寄存器中的内容, 其中存放的是PD的基地址(cr3 的高20为就是PD基地址的高20位, 低12位为0)</p><p><img src="/4Cc3.github.io/images/pasted-78.png" alt="upload successful">  </p><p>然后这里我们按照上面的步骤来, 首先要找到PDE, 也即是说, 这里是需要用ca83000+3e3*4 来找到对应的PDE(因为前面说过, 线性地址的高10位是PDE的索引, 类似c语言中数组的下标, 而每一个PDE是32bit,也就是4byte,所以这里需要用这个索引值乘来找到对应的位置, 这里想不通的同学可以回忆一下, 在计算机中, 一个地址对应存储的是一个字节)   </p><p>这里计算完成之后, 结果位0ca83f8c ,其对应地址存储的是0101a163, 这个就是我们要找的PDE  </p><p>PDE的高20bit为PT起始的高20bit, 也就是说, 我们要用0101a000来作为PD基地址, 而PDE的低12bit为页表属性, 这里其实关注一下它是否指向的是4MB大内存页就可以了, 如果不是就直接去找它对应的PTE, PTE也是4byte, 所以找法是0x0101a000+4*2e,这里的2e就是线性地址的中间十位  </p><p><img src="/4Cc3.github.io/images/pasted-79.png" alt="upload successful">  </p><p>然后可以看到这里PTE中存储的内容是0d566163。PTE高20bit指向的是内存页起始地址的高20bit, 即目标地址所在的内存页的基地址为0x0d566000, 低12bit代表的是内存也的属性  </p><p>这里0x0d566000加上前面线性地址的低十位（页内偏移）计算出来的就是真实的物理地址了，结果为0d56604d</p><p><img src="/4Cc3.github.io/images/pasted-80.png" alt="upload successful">  </p><p>在windbg中使用!pte可以直接看到这些结果, PTEcontains中高20位就是内存页的起始地址, 也就是下面的pfn的内容, pfn加上线性地址的低12位就可以定位到物理地址了  </p><h2 id="PAE分页"><a href="#PAE分页" class="headerlink" title="PAE分页"></a>PAE分页</h2><p>PAE分页相较于经典的分页来说, PD和PDE都从32bit拓展到64bit, 这样物理地址就可以拓展到64GB, 并且原来的二级页表结构更改为了三级结构, 现在多加了一级页目录指针表(Page Directory Pointer Table, PDPT), 这里的PDPT包含四个64bit的PD, 每个PD描述1GB的线性空间, 4个PD可以描述4GB的线性空间。</p><h2 id="大内存页"><a href="#大内存页" class="headerlink" title="大内存页"></a>大内存页</h2><p>之前提到了PDE指向的不仅仅是PT，有可能指向一个4MB的大内存页（当PS位为1时，代表pagesize为4MB）。  </p><p> + </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>实验: flask框架连接mysql数据库</title>
    <link href="/4Cc3.github.io/2024/05/09/%E5%AE%9E%E9%AA%8C-flask%E6%A1%86%E6%9E%B6%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/4Cc3.github.io/2024/05/09/%E5%AE%9E%E9%AA%8C-flask%E6%A1%86%E6%9E%B6%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先安装Flask, PyMySQL,Flask-SQLalchemy  ,这些通过pip都可以直接安装  </p><h3 id="配置工作"><a href="#配置工作" class="headerlink" title="配置工作"></a>配置工作</h3><p>首先需要一个URI的配置,以下是URI连接时用到的配置信息  </p><table><thead><tr><th align="center">占位符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">dialect</td><td align="center">数据库，如：sqlite、mysql、oracle等</td></tr><tr><td align="center">driver</td><td align="center">数据库驱动，如前面安装的：pymysql</td></tr><tr><td align="center">username</td><td align="center">登录数据库用户名</td></tr><tr><td align="center">password</td><td align="center">登录数据库密码</td></tr><tr><td align="center">host</td><td align="center">数据库部署 IP 地址</td></tr><tr><td align="center">port</td><td align="center">端口</td></tr><tr><td align="center">database</td><td align="center">数据库库名</td></tr></tbody></table><p>而URI字符串构造形式为<br><code>dialect+driver://username:password@host:port/database</code>  </p><p>在Flask类中, 还有一个对象叫config对象, 该属性是一个dict, 需要进行相应的配置使其生效<br>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">DB_URI = <span class="hljs-string">&#x27;mysql+pymysql://root:passwd@localhost:3306/school&#x27;</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = DB_URI<br><span class="hljs-comment">#数据库追踪</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="hljs-literal">False</span><br><span class="hljs-comment">#显示底层语句</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="hljs-literal">True</span><br><br>```  <br><br>这里的config具体配置还可以从JSON文件导入, 实现配置分离  <br><br>```python<br><span class="hljs-keyword">import</span> json<br>app.config.from_file(<span class="hljs-string">&quot;config.json&quot;</span>, load=json.load)<br>```  <br><br><br><span class="hljs-comment">### 建立上下文 ###  </span><br><br><br>这里好像是出于程序安全性考虑, 连接到数据库必须存在上下文, 所以需要一个基本的flask网页  <br><br>向代码中添加index控制器  <br><br>```python<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    sql =  text(<span class="hljs-string">&#x27;SELECT * FROM school.course;&#x27;</span>)<br>    result = db.session.execute(sql)<br>    courses = result.fetchall()<br>    <span class="hljs-built_in">print</span>(courses)<br>    <span class="hljs-keyword">return</span> flask.render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>, courses=courses)<br><br></code></pre></td></tr></table></figure><p>在程序根目录下的templates文件夹中创建index.html, 随便写点东西, 保证文件存在就行  </p><p>随后就可以测试了   </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>完整代码  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> flask<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy<br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> text<br>app = Flask(__name__)<br>DB_URI = <span class="hljs-string">&#x27;mysql+pymysql://root:passwd@localhost:3306/school&#x27;</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = DB_URI<br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="hljs-literal">False</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="hljs-literal">True</span><br>db = SQLAlchemy(app)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    sql =  text(<span class="hljs-string">&#x27;SELECT * FROM school.course;&#x27;</span>)<br>    result = db.session.execute(sql)<br>    courses = result.fetchall()<br>    <span class="hljs-built_in">print</span>(courses)<br>    <span class="hljs-keyword">return</span> flask.render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>, courses=courses)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">with</span> app.app_context():<br>        app.run()<br><br><br></code></pre></td></tr></table></figure><p>运行之后, 就可以在终端中查看数据库的输出了, 这里是因为我本地已经创建过一个school数据库, 里面有一些表(做学校数据库实验的时候搞的) 所以在复现本实验的时候需要自己创建一个数据库,并修改查询语句来保证程序正确运行  </p><p><img src="/4Cc3.github.io/images/pasted-66.png" alt="运行结果">  </p><p>可以看到console中输出了查询的结果</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WriteUp: 2024蓝桥杯</title>
    <link href="/4Cc3.github.io/2024/04/28/WriteUp-2024%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <url>/4Cc3.github.io/2024/04/28/WriteUp-2024%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
    
    <content type="html"><![CDATA[<p>记录一下这一场比赛, 说实话协会内对蓝桥杯还是很抵触的 , 但是为了协会的发展和社团的转正也是没有办法, 毕竟学校对蓝桥杯的认可度比DEFCON都高，如果没有什么成绩协会肯定是办不下去的，这里简单记录一下蓝桥杯的两道逆向(仅有的两道)  </p><p>顺便一提，蓝桥杯没有web题还是非常爽的，爱了</p><h2 id="happytime"><a href="#happytime" class="headerlink" title="happytime"></a>happytime</h2><p>看一下文件格式，是一个ELF格式的文件，题目提示说是个TEA，但是看了下代码实际上并不是一个标准的TEA</p><p><img src="/4Cc3.github.io/images/pasted-62.png" alt="upload successful">  </p><p>这里看到没有去除符号表, 函数也是一眼就看出来哪个是主要逻辑了  </p><p>看到cry里面, 这里简单对变量进行了命名  </p><p>这里对该函数仔细分析一下, 函数主要是做一个循环, 循环次数是415 &#x2F; length + 114次, 可以看到这里也是出题人的恶趣味, 然后就是sum每次都是减一个很经典的数字, 这个用findcrypto也是能识别出来是TEA的。  </p><p>然后就是函数具体的加密部分了，这里的核心加密语句为：<br><code>*v1 += ((next ^ sum) + (lastv ^ *(_DWORD *)(4LL * (index ^ i &amp; 3) + key))) ^ (((4 * next) ^ (lastv &gt;&gt; 5))+ ((next &gt;&gt; 3) ^(16 * lastv)));</code>  </p><p>这里可以做个实验, 这里对v1的运算是可逆的, 也就是说原本加了多少数, 如果想还原密文的话减掉那个数就可以了  </p><p>然后再看, 每一轮运算里是有一个for循环, for结束后又执行了一个语句 </p><p><code>    *v2 += ((*input ^ sum) + (lastv ^ *(_DWORD *)(4LL * (index ^ i &amp; 3) + key))) ^ (((4 * *input) ^ (lastv &gt;&gt; 5)) + ((*input &gt;&gt; 3) ^ (16 * lastv)));</code></p><p>这个语句和上一条语句可以看到一些差距, 最主要的就是input的取值, 一个是取input[i+1], 另一个是取input[0], 这里就可以分析出, 一轮加密干的事情是用input[i+1]给input[i]加密, 当i等于10时(也就是length - 1 ), 此时由于并不存在一个input[i+1], 所以就需要使用input[0]来给input[i]做加密, 还有一个需要注意的是lastv这个值, lastv初始值是input[length-1], 也就是input的最后一个值, 进入一轮加密后lastv在每一轮加密后变为当前的值 换句话说, 每一轮的加密都需要用input[i-1]和input[i+1]来给input[i]做加密. 那么逻辑分析出来, 逆向就很容易了, 对于每一轮的操作, 首先要先将lastv置为input[length-2], next置为input[0], 将input[i-1]恢复出来, 然后再进入一个从length -2 到 0 的循环, 这里每一轮循环使用input[i-1]和input[i+1]来恢复input[i], 当i等于0的时候, lastv应该是input[length-1], 这里需要注意一下  </p><p>然后就是最坑爹的地方了, 请看图  </p><p><img src="/4Cc3.github.io/images/pasted-64.png" alt="upload successful">  </p><p>当时比赛的时候没做出来主要是栽在这了, 这里调用的时候往里头传的这个key是一个int64的数, 而使用的时候直接是把key作为一个64位的数在用, 也就是说这里的key其实就是一个整数而不是一个指针类型, 所以在IDA中使用这个key的时候使用了类型转换将其转换成了int32类型(也就是DWORD) 所以当时写脚本的时候没注意类型,直接从ida里面复制的代码, 直接执行的 , 所以就导致没把误把key当做了一个int*, 所以就没把flag整出来, 太蠢了  </p><p>剩下一个就是端序的问题, 这题好像默认就是小端绪, 所以直接把密文复制出来从最低位输出就能出flag  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">//decry.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> length = <span class="hljs-number">11</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> input[<span class="hljs-number">12</span>];<br><span class="hljs-type">int</span> key[<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> index;<br><span class="hljs-type">int</span> turn = <span class="hljs-number">415</span> / length + <span class="hljs-number">114</span>;<br><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sum = <span class="hljs-number">1387842591</span> ;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lastv = input[length - <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>input[<span class="hljs-number">0</span>] = <span class="hljs-number">1208664588</span>;<br>input[<span class="hljs-number">1</span>] = <span class="hljs-number">0xCE9037F2</span>;<br>input[<span class="hljs-number">2</span>] = <span class="hljs-number">0x8C212018</span>;<br>input[<span class="hljs-number">3</span>] = <span class="hljs-number">244490637</span>;<br>input[<span class="hljs-number">4</span>] = <span class="hljs-number">0xA4035274</span>;<br>input[<span class="hljs-number">5</span>] = <span class="hljs-number">611560113</span>;<br>input[<span class="hljs-number">6</span>] = <span class="hljs-number">0xA9EFDB58</span>;<br>input[<span class="hljs-number">7</span>] = <span class="hljs-number">0xA52CC5C8</span>;<br>input[<span class="hljs-number">8</span>] = <span class="hljs-number">0xE432CB51</span>;<br>input[<span class="hljs-number">9</span>] = <span class="hljs-number">3494810147</span>;<br>input[<span class="hljs-number">10</span>] = <span class="hljs-number">1875931283</span>;<br>cout&lt;&lt;(<span class="hljs-type">int</span>)input[<span class="hljs-number">4</span>]&lt;&lt;endl;<br>key[<span class="hljs-number">0</span>] = <span class="hljs-number">2036950869</span>;<br>key[<span class="hljs-number">1</span>] = <span class="hljs-number">1731489644</span>;<br>key[<span class="hljs-number">2</span>] = <span class="hljs-number">1763906097</span>;<br>key[<span class="hljs-number">3</span>] = <span class="hljs-number">1600602673</span>;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=turn;j++)&#123;<br>lastv = input[length - <span class="hljs-number">2</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *v1,next;<br>index = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>v1 = &amp;input[length - <span class="hljs-number">1</span>];<br><br><span class="hljs-type">int</span> l1=(index ^ <span class="hljs-number">10</span> &amp; <span class="hljs-number">3</span>);<br><br>*v1 -= ((*input ^ sum) + (lastv ^key[l1] )) ^ (((<span class="hljs-number">4</span> * *input) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((*input &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length <span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<br>lastv = input[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>lastv = input[length<span class="hljs-number">-1</span>];<br>&#125;<br>next = input[i+<span class="hljs-number">1</span>];<br>v1 = &amp;input[i];<br><br><br><br><span class="hljs-type">int</span> l=(index ^ i &amp; <span class="hljs-number">3</span>);<br>*v1 -= ((next ^ sum) + (lastv ^ key[l])) ^ (((<span class="hljs-number">4</span> * next) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((next &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br><br> <br>&#125;<br><br><br><br>sum+= <span class="hljs-number">0x61C88647</span>;<br><br>&#125;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br>cout&lt;&lt;(<span class="hljs-type">char</span>)((input[i]&gt;&gt;(<span class="hljs-number">8</span>*j))&amp;<span class="hljs-number">0xff</span>);<br>&#125;<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;endl;<br><br><br><br>&#125;<br><br><br><br><br><br>```C++  加密脚本, 推测源代码就长这样, 这里的密文是flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _DWORD unsigned int </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> length = <span class="hljs-number">11</span>;<br><br>__int64 key[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-F0h] BYREF</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> input[<span class="hljs-number">12</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-E0h]</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>key[<span class="hljs-number">0</span>] = <span class="hljs-number">2036950869</span>;<br>key[<span class="hljs-number">1</span>] = <span class="hljs-number">1731489644</span>;<br>key[<span class="hljs-number">2</span>] = <span class="hljs-number">1763906097</span>;<br>key[<span class="hljs-number">3</span>] = <span class="hljs-number">1600602673</span>;<br><br>input[<span class="hljs-number">0</span>] = <span class="hljs-number">0x666c6167</span>;<br>input[<span class="hljs-number">1</span>] = <span class="hljs-number">0x7b787878</span>;<br>input[<span class="hljs-number">2</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">3</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">4</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">5</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">6</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">7</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">8</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">9</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">10</span>] = <span class="hljs-number">0x7878787d</span>;<br><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *v1; <span class="hljs-comment">// rax</span><br>_DWORD *v2; <span class="hljs-comment">// rax</span><br>__int64 result; <span class="hljs-comment">// rax</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lastv; <span class="hljs-comment">// [rsp+20h] [rbp-18h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sum; <span class="hljs-comment">// [rsp+24h] [rbp-14h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+28h] [rbp-10h]</span><br><span class="hljs-type">int</span> turn; <span class="hljs-comment">// [rsp+2Ch] [rbp-Ch]</span><br><span class="hljs-type">int</span> index; <span class="hljs-comment">// [rsp+30h] [rbp-8h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> next;<br>turn = <span class="hljs-number">415</span> / length + <span class="hljs-number">114</span>;<br>turn =<span class="hljs-number">3</span>;<br>sum = <span class="hljs-number">0</span>;<br>lastv = input[length - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">do</span><br>&#123;<br>sum -= <span class="hljs-number">0x61C88647</span>;<br>index = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; ++i )<br>&#123;<br>next = input[i + <span class="hljs-number">1</span>];<br>v1 = &amp;input[i];<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">9</span>)&#123;<br>cout&lt;&lt;key[(index ^ i &amp; <span class="hljs-number">3</span>)]&lt;&lt;endl;<br>cout&lt;&lt;( ((*input ^ sum) + (lastv ^ key[(index ^ i &amp; <span class="hljs-number">3</span>)])) ^ (((<span class="hljs-number">4</span> * *input) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((*input &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv))))&lt;&lt;endl;<br><br>&#125;<br> *v1 += ((next ^ sum) + (lastv ^ key[(index ^ i &amp; <span class="hljs-number">3</span>)])) ^ (((<span class="hljs-number">4</span> * next) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((next &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br>lastv = *v1;<br><br><br>&#125;<br>v2 = &amp;input[length - <span class="hljs-number">1</span>];<br>cout&lt;&lt;(index ^ i &amp; <span class="hljs-number">3</span>)&lt;&lt;endl;<br>cout&lt;&lt;*(_DWORD *)(<span class="hljs-number">4LL</span> * (index ^ i &amp; <span class="hljs-number">3</span>) + key)&lt;&lt;endl;<br>*v2 += ((*input ^ sum) + (lastv ^ key[(index ^ i &amp; <span class="hljs-number">3</span>)   ])) ^ (((<span class="hljs-number">4</span> * *input) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((*input &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br>result = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)*v2;<br>lastv = result;<br>--turn;<br>&#125;<br><span class="hljs-keyword">while</span> ( turn );<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br><br>cout&lt;&lt;<span class="hljs-string">&quot;input[&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;] = &quot;</span>&lt;&lt;input[i]&lt;&lt;<span class="hljs-string">&quot;;&quot;</span>&lt;&lt;endl;<br><br>&#125;<br>cout&lt;&lt;sum&lt;&lt;endl;<br><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><p>白给的题, 动态调试一下, flag是明文的  </p><p><img src="/4Cc3.github.io/images/pasted-65.png" alt="upload successful">  </p><p>flag{12601b2b-2f1e-468a-ae43-92391ff76ef3}  </p><p>蓝桥杯虽然收费, 还挺贵, 但至少打着不坐牢, 新手可以打这个练练手, 没啥不好的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>教程: Mysql语句</title>
    <link href="/4Cc3.github.io/2024/04/22/%E6%95%99%E7%A8%8B-Mysql%E8%AF%AD%E5%8F%A5/"/>
    <url>/4Cc3.github.io/2024/04/22/%E6%95%99%E7%A8%8B-Mysql%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>本教程致力打造一个mysql最速入门教程, 以最简介的语言教会你如何写sql语句, 适用人员包括但不限于: 即将考试的大学生, 想要了解数据库的产品经理, 想要快速入门sql注入的安全人员</p><p>Mysql中最主要的四个部分是增删改查, 而这四个部分中最主要的部分是查询的部分, 查询语句的写法是最为复杂的, 除此之外Mysql中还有一些关于权限的操作, 这里回一一进行介绍</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="增加一个数据库"><a href="#增加一个数据库" class="headerlink" title="增加一个数据库"></a>增加一个数据库</h3><p>一台主机中运行一个DBMS, 也就是mysql, 一个DBMS中可以存在多个数据库, 这里介绍如何创建数据库  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> school;<br></code></pre></td></tr></table></figure><p>上面的语句的意思为创建一个名为school的数据库, if not exists为可选项, 代表如果该数据库不存在才进行创建, 如果存在就不创建, 这么做的原因是防止报错  </p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>创建一个表使用如下语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">TABLE</span> student(<br><br>    Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,<br>    Sname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">8</span>),<br>    Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>),<br>    Sage <span class="hljs-type">SMALLINT</span> <span class="hljs-keyword">check</span>(Sage <span class="hljs-operator">&gt;</span><span class="hljs-number">18</span>),<br>    Sdept <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>)  <span class="hljs-keyword">DEFAULT</span>(&quot;JSJ&quot;),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br><br>);<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">TABLE</span> course(<br>    Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    Cname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    Cpno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>),<br>    Ccredit TINYINT,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Cno) <br><br>)<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">TABLE</span> sc(<br><br>    Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    Grade <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">12</span>,<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno,Cno)<br>    <span class="hljs-keyword">CONSTRAINT</span> FK_student_sno (Sno) <span class="hljs-keyword">FOREIGN</span> KEY <span class="hljs-keyword">REFERENCES</span> student(Sno),<br><br>    <span class="hljs-keyword">CONSTRAINT</span> FK_student_Cno (Cno)  <span class="hljs-keyword">FOREIGN</span> KEY <span class="hljs-keyword">REFERENCES</span> student(Cno)<br>    <br><br>);<br><br><br><br></code></pre></td></tr></table></figure><p>我们来看上面的语句, 一一进行解释</p><p>首先是 not null 这个语句的意思是约束这个表的这一列不为空  </p><p>unique代表这一列是独一无二的, 不能重复的</p><p>创建一个表的时候, 列名的后面是这个列的数据类型,这里DECIMAL(12,1) 的意思是一个十二位的数字, 其中小数占1位  </p><p>constraint 代表着建立一个约束, 后面跟着的是这个约束的名称, 名称后面是这个约束的具体内容, 像这里的sc表就建立了一个外键约束, sno列参考student里的sno列, cno列参考student的cno列, 这里还可以设定其在变化时的操作,例如 在更新时执行casecade 之类的操作</p><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="删除一个数据库"><a href="#删除一个数据库" class="headerlink" title="删除一个数据库"></a>删除一个数据库</h3><p>删除数据库使用语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database if <span class="hljs-keyword">exists</span> schools;<br></code></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="修改一个数据库"><a href="#修改一个数据库" class="headerlink" title="修改一个数据库"></a>修改一个数据库</h3>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验: MFC逆向</title>
    <link href="/4Cc3.github.io/2024/04/14/%E5%AE%9E%E9%AA%8C-MFC%E9%80%86%E5%90%91/"/>
    <url>/4Cc3.github.io/2024/04/14/%E5%AE%9E%E9%AA%8C-MFC%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>首先, MFC是有消息映射和消息分发队列的, 这就导致其反编译出的代码不是那么好看, 所以对于MFC这种程序的逆向就会稍微有别于普通的程序, 这里以清华MLM模型提供的示例程序为例演示MFC逆向的基本流程</p><p>(后续如果有机会的话可能会写一篇关于MLM的使用测评)</p><h3 id="在IDA中导入MFC函数的结构体"><a href="#在IDA中导入MFC函数的结构体" class="headerlink" title="在IDA中导入MFC函数的结构体"></a>在IDA中导入MFC函数的结构体</h3><p> MFC的消息映射类型都是长这个样的</p><p> 消息映射入口<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AFX_MSGMAP_ENTRY</span></span><br><span class="hljs-class">&#123;</span><br>  UINT nMessage;<br>  UINT nCode;<br>  UINT nID;<br>  UINT nLastID;<br>  UINT_PTR nSig;<br>  <span class="hljs-type">void</span> (*pfn)(<span class="hljs-type">void</span>);<br>&#125;;<br><br><br></code></pre></td></tr></table></figure></p><p> 消息映射<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AFX_MSGMAP</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">const</span> AFX_MSGMAP *(__stdcall *pfnGetBaseMap)();<br>  <span class="hljs-type">const</span> AFX_MSGMAP_ENTRY *lpEntries;<br>&#125;;<br><br> <br></code></pre></td></tr></table></figure></p><p> 在view -&gt; subview 中找到localtype, 插入这两个结构体, 并同步到idb中去(这样才会对反编译的代码生效)</p><p><img src="/4Cc3.github.io/images/pasted-53.png" alt="upload successful"></p><h3 id="查找人工手写的函数"><a href="#查找人工手写的函数" class="headerlink" title="查找人工手写的函数"></a>查找人工手写的函数</h3><p>这里一般是需要对MFC的函数地址进行查询, 一般是使用XSPY对桌面窗口的句柄进行查询, 但是这里XSPY不知道为啥查不出该程序的函数, 所以只能自己去手动找了</p><p><img src="/4Cc3.github.io/images/pasted-54.png" alt="upload successful">  </p><p>这里的话只能是按照经验去找了, 这里MFC的消息映射结构一般都是这个样子的, 一大堆db数据,有很多0 ,并且时不时会出现一个地址, 一般跟在一大堆库MFC库函数后面的, 且都在rdata段</p><p>点edit -&gt; struct var 给该段转换为我们刚刚插入的结构体, 一般是先插入一个AFX_MSGMAP, 然后再插入若干个AFX_MSGMAP_ENTRY 这样,这里的AFXMSGMAP起到的是一个表头的作用, 转换完结构后IDA中的代码就会变成这样  </p><p><img src="/4Cc3.github.io/images/pasted-55.png" alt="upload successful">  </p><p>那我们此时就能看到, 转换完后的最后一个成员变量就是函数地址, 双击即可跟入了</p><p>上面的操作也仅仅做演示, 因为可以看到这么转换完的函数仍然是一个MFC的库函数,并不是什么人工手写的东西</p><p>这里的话往上翻一下, 可以翻到这个 </p><p><img src="/4Cc3.github.io/images/pasted-56.png" alt="upload successful"></p><p>这里箭头所指的地方是IDA错误的识别了这个结构, 只识别了一半, 这里需要将它转化为db 然后再应用我们新增的MFX结构体</p><p>至于怎么看出来这个地方需要转化成db的, 也只能说是经验之谈了</p><p><img src="/4Cc3.github.io/images/pasted-57.png" alt="upload successful">  </p><p>这里转换完之后就长这样,可以跟进看里面的函数具体的内容</p><p>这里的sub_7FF6A80E1B70 就是主要加密部分了</p><h3 id="逻辑逆向"><a href="#逻辑逆向" class="headerlink" title="逻辑逆向"></a>逻辑逆向</h3><p>这里看下函数, 发现一个哈希加密的东西, 上微软文档看下函数的API</p><p><img src="/4Cc3.github.io/images/pasted-59.png" alt="upload successful"></p><p>然后发现是MD5<br><img src="/4Cc3.github.io/images/pasted-58.png" alt="upload successful">  </p><p><img src="/4Cc3.github.io/images/pasted-60.png" alt="upload successful">  </p><p>这里有一串神秘数字,应该是key,给它md5解密一下  </p><p><img src="/4Cc3.github.io/images/pasted-61.png" alt="upload successful">  </p><p>然后发现也是挺白给的密码,这里就逆向结束了  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MFC逆向如果没有混淆或者是其它反逆向手段的话还是很好逆的, 需要注意的是记得常去搜MFC标准函数的文档, 查看这些函数的作用, 反正这个年代的IDA已经能全识别出来了, 虽然MFC已经逐步被淘汰了, MFC逆向似乎没啥企业价值了, 但是你去逆一下某些大学与其教学水平同样落后的学校的软件还是很有用的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C#学习</title>
    <link href="/4Cc3.github.io/2024/04/08/C-%E5%AD%A6%E4%B9%A0/"/>
    <url>/4Cc3.github.io/2024/04/08/C-%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本人会在这里记录我的C#学习过程中遇到的有意思的问题  </p><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装主要由以下几个修饰符实现:  </p><p>public：所有对象都可以访问, 无论是本文件还是其它引用本文件的文件都可以访问；  </p><p>internal：本文件内的所有对象可以访问；  </p><p>private：只有对象内部可以访问；  </p><p>protected：只有该类对象及其子类对象可以访问  </p><p>protected internal：访问限于当前程序集或派生自包含类的类型。  </p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>c#中的方法与c++的大部分特性都相同, 这里调几个重点的讲下  </p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>看上面的代码里面调用方法时使用了ref关键字, 这个有区别于c++中的引用, c#中需要使用ref关键字来表明这里传递的是一个引用型变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> a ,<span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> b</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> c = a;<br>            a = b;<br>            b = c;<br>        &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>         &#123;<br>            Program n = <span class="hljs-keyword">new</span> Program(); <span class="hljs-comment">// 这里必须实例化才能调用Program类中的方法</span><br>            <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>            <span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>;<br>            n.swap(<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, a, b);<br>        &#125;<br>    &#125;<br>&#125;<br>```  <br><br><br><br><br><span class="hljs-meta">### 输出参数</span><br><br><br>这个是c<span class="hljs-meta">#中特有的一个特性, 它跟引用类似, 但是其**不需要赋初始值**也可以传递给函数  </span><br><br>``` C<span class="hljs-meta">#</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">give</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> a, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> b</span>)</span><br>        &#123;<br>            a = <span class="hljs-number">1001</span>;<br>            b = <span class="hljs-number">2001</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>         &#123;<br>            Program n = <span class="hljs-keyword">new</span> Program();<br>            <span class="hljs-built_in">int</span> c, d;<br>            n.give(<span class="hljs-keyword">out</span> c, <span class="hljs-keyword">out</span> d);<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, c, d);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码输出<code> 1001 2001</code> , 这里就是使用了输出参数, c和d都被输出了值  </p><p>最后c#中的方法都是写在类里面的, 然后Main这个方法又是一个独立于类的方法(因为它是以static声明的), 在如果在同一个类中又有自己实现的方法又有Main, 那么在Main中调用这个方法必须先实例化   </p><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>? 单问号用于对 int、double、bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 Nullable 类型的。<br><code>e.g int? i = 3; </code></p><p>?? 双问号用于判断一个变量在为 null 的时候返回一个指定的值。  </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">double</span>? num1 = <span class="hljs-literal">null</span>;<br>num3 = num1 ?? <span class="hljs-number">5.34</span>;      <span class="hljs-comment">// num1 如果为空值则返回 5.34</span><br>Console.WriteLine(<span class="hljs-string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);<br>```  <br><br>num3 的值： <span class="hljs-number">5.34</span><br><br><br><br><br><span class="hljs-meta">## 数组  </span><br><br><br><span class="hljs-meta">### 数组的声明</span><br><br>在C<span class="hljs-meta">#中声明数组是用</span><br>`datatype[] arrayName;`语法声明的, C<span class="hljs-meta">#中的数组在初始化的时候不会在内存中存在, 不能直接使用, 必须要使用new关键字对其进行赋值(C#是一个非常面向对象的语言, 一切的数据类型都是对象)   </span><br><br>使用`<span class="hljs-built_in">double</span> arr[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[<span class="hljs-number">10</span>]`来新声明一个数组, 这个数组在经过这个语句赋值之后就可以使用了  <br><br><br>```C<span class="hljs-meta">#</span><br>balance[<span class="hljs-number">0</span>] = <span class="hljs-number">4500.0</span>;<br><span class="hljs-built_in">double</span>[] balance = &#123; <span class="hljs-number">2340.0</span>, <span class="hljs-number">4523.69</span>, <span class="hljs-number">3421.0</span>&#125;;<span class="hljs-comment">//使用初始化容器初始化</span><br><br><br><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>]  &#123; <span class="hljs-number">99</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">92</span>, <span class="hljs-number">97</span>, <span class="hljs-number">95</span>&#125;;<span class="hljs-comment">//当然也可以在声明时直接使用初始化容器</span><br><br><br><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]  &#123; <span class="hljs-number">99</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">92</span>, <span class="hljs-number">97</span>, <span class="hljs-number">95</span>&#125;; <span class="hljs-comment">//如果使用了初始化容器,则数组的大小是可以忽略的,可以自动推理其长度</span><br><br><br><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]  &#123; <span class="hljs-number">99</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">92</span>, <span class="hljs-number">97</span>, <span class="hljs-number">95</span>&#125;;<br><span class="hljs-built_in">int</span>[] score = marks;<span class="hljs-comment">//可以使用这种方式初始化, 但是这种方式的本质和c++中的指针类似, score和marks指向同一个内存地址</span><br><br><br></code></pre></td></tr></table></figure><p>上面的数组都是使用了初始化容器进行初始化, 所以没有指定数组大小也能通过编译,编译器会自动将数组的长度设初始化容器的长度 , 但是在不使用初始化容器的情况下, 必须要在实例化时对数组的大小进行声明,否则无法通过编译</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] _c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[];<span class="hljs-comment">// 错误, 因为new int后没有指定数组的具体大小</span><br><span class="hljs-built_in">int</span>[] _c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 正确</span><br><br></code></pre></td></tr></table></figure><p>除此之外, 数组也可以作为参数传递给函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span><br>  &#123;<br>     <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">getAverage</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> size</span>)</span><br>     &#123;<br>        <span class="hljs-built_in">int</span> i;<br>        <span class="hljs-built_in">double</span> avg;<br>        <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        &#123;<br>           sum += arr[i];<br>        &#125;<br><br>        avg = (<span class="hljs-built_in">double</span>)sum / size;<br>        <span class="hljs-keyword">return</span> avg;<br>     &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><p>访问可以通过下标直接访问, 这一点与c++无异</p><p>当然, C#提供了迭代器来访问数组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] n=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;<br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span>  n)&#123;<br><br>Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>,i)<br>&#125;<br><br>```  <br><br><br>这个东西就和python中的`<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list`这种语法很像了,n得是一个可迭代对象, i是每个元素  <br><br><br><span class="hljs-meta">### 多维数组  </span><br><br>C<span class="hljs-meta">#中的多维数组和C++不太一样, string 类型的二维数组为:`string [,] names;` int类型的三维数组为`int [ , , ] ;`, 它这是靠方括号里的逗号来确定维度的</span><br><br><br>而访问的时候也不像c++那样要好几个方括号,C<span class="hljs-meta">#访问多维数组是用`m[2,3]`这样的方式访问的, 是方括号里用逗号区分维度的  </span><br><br><br>多维数组也可以赋初始值,其赋值方法为:  <br><br>```C<span class="hljs-meta">#</span><br><span class="hljs-built_in">int</span> [,] a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] &#123;<br> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; ,   <span class="hljs-comment">/*  初始化索引号为 0 的行 */</span><br> &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125; ,   <span class="hljs-comment">/*  初始化索引号为 1 的行 */</span><br> &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;   <span class="hljs-comment">/*  初始化索引号为 2 的行 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用上面的初始化列表嵌套对多维数组进行初始化</p><p>ps. C#中,数组可以使用GetLength方法获取数组的长度, 因为这玩意可以变长,然后这个数组是从Array类继承下来的, 所以想知道数组都有哪些内置方法可以去看下微软文档, 里面还是有蛮多方法的, 排序逆序查找啥的都有[<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.array?view=net-7.0#methods]">https://learn.microsoft.com/zh-cn/dotnet/api/system.array?view=net-7.0#methods]</a></p><h3 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h3><p>c#中的交错数组定义为</p><p><code>int[][] a</code></p><p>此时并没有在内存中为数组分配空间, 如果需要使用该数组, 则需要使用</p><p><code>int [][] a = new int[5][]</code><br>这种方式来为数组分配空间<br>这是因为数组是变长的, 所以可以不指定大小, 但是这里new int关键字后面的第一个秩标识符必须是要确定数组大小的, 否则会报错  </p><p>这是因为交错数组实际上也是一个数组, 只不过数组中的每一个元素都是一个数组, 并且元素数组的长度可以不统一<br>例如  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[][] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">92</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">85</span>,<span class="hljs-number">66</span>,<span class="hljs-number">87</span>,<span class="hljs-number">88</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><p>这个代码声明了一个int类型的二维交错数组scores, 可以看到scores中的数组长度不是统一的  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[,] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] &#123;  &#123; <span class="hljs-number">92</span>, <span class="hljs-number">93</span>, <span class="hljs-number">94</span> &#125;,  &#123; <span class="hljs-number">85</span>, <span class="hljs-number">66</span>, <span class="hljs-number">87</span>, <span class="hljs-number">88</span> &#125; &#125;;<span class="hljs-comment">//错误, 因为数组是两行四列, 则数组中每一个元素都必须四个元素的初始化容器(因为需要有四列)</span><br><br><span class="hljs-built_in">int</span>[][] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">92</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">85</span>,<span class="hljs-number">66</span>,<span class="hljs-number">87</span>,<span class="hljs-number">88</span>&#125;&#125;;<span class="hljs-comment">//正确, 因为使用交错数组说明scores中每一个元素都是一个数组, 数组的长度不需要满足什么要求</span><br><br><span class="hljs-built_in">int</span>[][] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] <span class="hljs-comment">// 错误, 不允许交错数组在定义时仅允许第一个秩标识符中有数字, 这么规定是因为交错数组是用来解决在数组中存放数组的问题的, 其原型为int[]  [] , 意思是需要一个int[]类型的数组,而在分配内存空间时, 编译器会从左到右检查语句,当检查到交错数组时, 其只接受后[number][][]....这样形式的字符,也就是说交错数组的第二个位置不能填写数字来规定数组的具体大小</span><br><br><br><span class="hljs-built_in">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123; <span class="hljs-number">3</span>, <span class="hljs-number">6</span> &#125;, <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123; <span class="hljs-number">4</span>, <span class="hljs-number">8</span> ,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">43</span>,<span class="hljs-number">45</span>,<span class="hljs-number">2</span>,<span class="hljs-number">32</span>,<span class="hljs-number">23</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2</span>,<span class="hljs-number">32</span>,<span class="hljs-number">532</span>&#125; &#125;;<span class="hljs-comment">//正确, 这里的newint[][]关键字没有填写第一个秩标识符内的数字是因为这个数组进行了初始化, 则数组的长度等于初始化容器的个数, 这个数组长度是编译器自动推理的所以不需要(此处为5)</span><br><br><br><br></code></pre></td></tr></table></figure><p>此处进行一个总结</p><ul><li><p>多维数组和交错数组必须要在实例化时指定其大小, 如果使用了初始化容器则不需要指定大小</p></li><li><p>多维数组一旦规定了其大小, 则元素中每一行的个数都必须与规定大小时相同, 否则编译器报错, 但是交错数组不需要遵守这个规定, 交错数组中的每一个元素都是一个数组, 并且其可以变长(以二维数组为例)</p></li><li><p>在不使用初始化容器的情况下, 多维数组的定义方式为 <code>int[,] a = new int[5,5]</code>;   交错数组的定义方式为 int [][] a &#x3D; new int [5][];  (更高维度的数组类比)</p></li></ul><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="null条件运算符"><a href="#null条件运算符" class="headerlink" title="null条件运算符"></a>null条件运算符</h3><p>在实际开发中会遇到很多关于判断特殊数据的地方, 因此会有大量的NULL需要进行检测, 但是如果使用显式的判断语句判断的话就会使代码变得冗长, 所以可以使用null条件运算符 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">foreach</span>(Product p <span class="hljs-keyword">in</span> Product.GetProduct())&#123;<br><span class="hljs-built_in">string</span> name  = p?.name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的表达式为, 当p不为空时, 才把p.name赋值给name, 这么做有效的防止了空引用现象  </p><p>当然, 之类的null条件运算符是可以传递的  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">foreach</span>(Product p <span class="hljs-keyword">in</span> Product.GetProduct())&#123;<br><span class="hljs-built_in">string</span> relatedName = p?.Related?.Name;<br>&#125;<br>```  <br><br><br><br>这里的relatedName只有在p不为空, 且p的Related属性不为空的情况下才会被赋值  <br><br><br>并且, 这里还可以使用<span class="hljs-literal">null</span>合并运算符来将<span class="hljs-literal">null</span>值反馈给程序  <br><br><br>```C<span class="hljs-meta">#</span><br><span class="hljs-keyword">foreach</span> (Product p <span class="hljs-keyword">in</span> Product.GetProducts()) &#123;<br><span class="hljs-built_in">string</span> name = p?.Name ?? <span class="hljs-string">&quot;&lt;No Name&gt;&quot;</span>;<br><br><br></code></pre></td></tr></table></figure><p>上述代码的效果为: 当p的Name属性为空值时, 将name置为 NoName 这将有助于实现空值检测</p><h3 id="自动实现属性"><a href="#自动实现属性" class="headerlink" title="自动实现属性"></a>自动实现属性</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span>? Price &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-keyword">public</span> Product Related &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br></code></pre></td></tr></table></figure><p>自动实现属性可以帮助简化代码, 上面的语句等价于</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br><span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>也就是说, 如果填了get和set, 那么这个属性就是可以读或者可以写的</p><h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">results.Add(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;name&#125;</span>, Price: <span class="hljs-subst">&#123;price&#125;</span>, Related: <span class="hljs-subst">&#123;relatedName&#125;</span>&quot;</span>);<br><br><br></code></pre></td></tr></table></figure><p>上述代码中, 字符串前加了一个$符号, 代表计算字符串时, 可以使用指定的变量或常量来填充这些槽(hole)  </p><p>像上述代码的槽中, 分别插入了name price relatedName变量, 那么代码会去当前上下文中寻找这些变量并进行替换</p><h2 id="C-高级"><a href="#C-高级" class="headerlink" title="C#高级"></a>C#高级</h2><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托的本质和C++中的函数指针非常相似  </p><p>委托是用来实现解耦的, 当一个功能没有完全实现时, 可以使用委托来代替它原本的位置, 从而不影响开发(例如数据库功能, 可以使用委托来实现, 在没有进入数据库相关开发之前可以使用静态内容来实现伪数据库, 在开发完成后可以进行替换)下面举个例子  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Class1.cs</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">delegantTest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CAL</span>&lt;<span class="hljs-title">t</span>&gt;(<span class="hljs-params">t a, t b</span>)</span>;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params">CAL&lt;<span class="hljs-built_in">int</span>&gt; c</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> c(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Program.cs</span><br><span class="hljs-keyword">using</span> delegantTest;<br>Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>Class1 a =<span class="hljs-keyword">new</span> Class1();<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">f1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>Console.WriteLine(a.func(f1));<br></code></pre></td></tr></table></figure><p>这里在主程序中定义了一个f1, 然后将f1作为参数传递给了a这个类中的func()</p><p>在Class1.cs中, <code>public delegate int CAL&lt;t&gt;(t a, t b);</code>语句是用户注册委托的, 它就像声明了一个类一样,需要指定一个返回值,和一个参数列表,这里参数列表可以使用泛型, 而实现委托的函数的参数列表和声明委托时必须一致, 实现委托的函数的返回类型必须和声明委托时的返回类型一致。  </p><p>这里官方给出的用法实际上并不是向func中直接传递函数作为参数的，而是使用以下方法<br><code>CAL&lt;int&gt; public static func1 = new CAL&lt;int&gt;(f1);</code><br>然后再<br><code>Console.WriteLine(func1());</code><br>也就是说, 实现委托是在对委托实例化时进行的  </p><p>下面可以再看一个例子</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Program.cs</span><br><span class="hljs-keyword">using</span> delegantTest;<br><span class="hljs-keyword">using</span> System;<br><br>Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">float</span> b</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)(a - b);<span class="hljs-comment">//这里参数上的差异是用来理解委托时声明的参数列表和实现委托的函数的参数列表要相同, 否则没办法正确实现委托</span><br>&#125;<br><br>CAL b = <span class="hljs-keyword">new</span> CAL(func);<br><br>Console.WriteLine(b(<span class="hljs-number">10</span>, <span class="hljs-number">29</span>));<br><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><br><span class="hljs-comment">//Class1.cs</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">delegantTest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CAL</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">float</span> b</span>)</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>像上面的代码在Class中注册了一个委托, 在Program中给委托实例化了, 实例化的时候需要给它传递一个参数, 这里的传递参数也和c++中相似, 如果传递的是一个函数的名称并且没有给其加上括号, 那么就说明传递的是一个类似函数指针的东西。当实例化完成之后就可以用b来执行函数体的功能了(但是说实话这么使用委托跟接口没啥区别, 所以不咋这么用, 委托的主要用法还是将需要更改的部分和不需要更改的部分区分开来,使用委托后如果需要更改函数体的功能只需要改实现委托的部分就好了, 所以最好还是更多的把委托当作函数的参数会好一些)  </p><h3 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h3><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。  </p><p>这里可以直接看菜鸟教程上的示例代码, 感觉讲的很清楚 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">NumberChanger</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateAppl</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>   &#123;<br>      <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num = <span class="hljs-number">10</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">AddNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span><br>      &#123;<br>         num += p;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MultNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> q</span>)</span><br>      &#123;<br>         num *= q;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>      &#123;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         <span class="hljs-comment">// 创建委托实例</span><br>         NumberChanger nc;<br>         NumberChanger nc1 = <span class="hljs-keyword">new</span> NumberChanger(AddNum);<br>         NumberChanger nc2 = <span class="hljs-keyword">new</span> NumberChanger(MultNum);<br>         nc = nc1;<br>         nc += nc2;<br>         <span class="hljs-comment">// 调用多播</span><br>         nc(<span class="hljs-number">5</span>);<br>         Console.WriteLine(<span class="hljs-string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());<br>         Console.ReadKey();<br>      &#125;<br>   &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>大概就这么个事吧, 委托被合并之后会越并越长的, 并且都是顺序执行, 而且返回的结果是最后一个调用的结果<br><img src="/4Cc3.github.io/images/pasted-82.png" alt="upload successful"></p><p>当使用-&#x3D;的时候, 会根据给定的函数名来把调用链上已经加入多播委托的函数删掉, 这里删除的是随机位置删除</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>实验: AES算法</title>
    <link href="/4Cc3.github.io/2024/03/09/%E5%AE%9E%E9%AA%8C-AES%E7%AE%97%E6%B3%95/"/>
    <url>/4Cc3.github.io/2024/03/09/%E5%AE%9E%E9%AA%8C-AES%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文主要参考<a href="https://zhuanlan.zhihu.com/p/78913397%E5%92%8Chttps://blog.csdn.net/qq_28205153/article/details/55798628%E4%B8%A4%E7%AF%87%E6%96%87%E7%AB%A0">https://zhuanlan.zhihu.com/p/78913397和https://blog.csdn.net/qq_28205153/article/details/55798628两篇文章</a></p><h1 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h1><h2 id="AES算法流程"><a href="#AES算法流程" class="headerlink" title="AES算法流程"></a>AES算法流程</h2><p>首先, AES是需要对输入字节序列进行分组的, 一般是16个字节一组, 也就是128位, 所以本次实验主要以128位的AES为主  </p><p><img src="/4Cc3.github.io/images/image_2.png" alt="字节序列排列方式">  </p><p><img src="/4Cc3.github.io/images/image_1.png" alt="算法流程图"></p><p>观察上图, 可以发现AES一般是十轮加密, 每一轮有四个操作, 分别是<em>字节代换, shift rows, mix column 密钥加层</em> 在密钥加层会需要用到一次密钥  </p><h2 id="密钥加层"><a href="#密钥加层" class="headerlink" title="密钥加层"></a>密钥加层</h2><p>密钥加层还是比较简单的, 其主要操作为将明文矩阵和子密钥矩阵一一对应的异或一下就好了  </p><p><img src="/4Cc3.github.io/images/pasted-39.png" alt="密钥加示意图">  </p><h2 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h2><p>字节代换主要是通过一个S_box来将字节进行一次映射, S_box有单独的生成算法, 在加密和解密时会使用不同的S_box  </p><p><img src="/4Cc3.github.io/images/pasted-40.png" alt="S_box示意图"></p><p>而代码中实现这个部分也很简单,比较常见的形式是<br><code>PlainArray[i] = S_box[PlainArray[i] &gt;&gt; 4][PlainArray[i] &amp; 0x0F];</code></p><p>上面的代码中, plainArray是一个字节数组, 每一个元素都是8bit, 而字节代换层要求, 对于一个byte元素来说, 其高四位作为映射时的行号,低四位作为列号, 而四位bit刚好可以表示0-15 16个数字, 对应S_box 16*16共256个元素  </p><p><img src="/4Cc3.github.io/images/pasted-41.png" alt="字节代换示意图"></p><h2 id="shiftRows"><a href="#shiftRows" class="headerlink" title="shiftRows"></a>shiftRows</h2><p>行位移就是将举证进行循环位移, 第一行不移动, 第二行向左移动1个位置, 第三行向左移动2个位置, 第三行向左移动3个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//加密时运行的shiftRows代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ShiftRows</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *PlainArray)</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-comment">//传入的PlainArray是一个从char类型的二维数组,其原型为char PlainArray[4][4] , 将其转换为int*类型时, 每次取值会取连续的4个字节, 也就是AES矩阵中的一行  </span><br>  <br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//第一行 不移位</span><br>  <span class="hljs-comment">//PlainArray[0] = PlainArray[0];</span><br><br>  <span class="hljs-comment">//第二行 左移8Bit</span><br>  PlainArray[<span class="hljs-number">1</span>] = (PlainArray[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">8</span>) | (PlainArray[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">24</span>);<br><br>  <span class="hljs-comment">//第三行 左移16Bit</span><br>  PlainArray[<span class="hljs-number">2</span>] = (PlainArray[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">16</span>) | (PlainArray[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>);<br><br>  <span class="hljs-comment">//第四行 左移24Bit</span><br>  PlainArray[<span class="hljs-number">3</span>] = (PlainArray[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">24</span>) | (PlainArray[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/4Cc3.github.io/images/pasted-42.png" alt="shiftRows图解"></p><p>而其对应的解密操作即为向相反的方向进行位移, 原来向左位移, 则解密时向右位移即可  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//解密时运行的shiftRows代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ReShiftRows</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *CipherArray)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//第一行 不移位</span><br>  <span class="hljs-comment">//CipherArray[0] = CipherArray[0];</span><br><br>  <span class="hljs-comment">//第二行 右移8Bit</span><br>  CipherArray[<span class="hljs-number">1</span>] = (CipherArray[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) | (CipherArray[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">24</span>);<br><br>  <span class="hljs-comment">//第三行 右移16Bit</span><br>  CipherArray[<span class="hljs-number">2</span>] = (CipherArray[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) | (CipherArray[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">16</span>);<br><br>  <span class="hljs-comment">//第四行 右移24Bit</span><br>  CipherArray[<span class="hljs-number">3</span>] = (CipherArray[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) | (CipherArray[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">8</span>);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而这里的左移和右移是反直觉的, 这个具体原因涉及到端序的问题, 不清楚的读者可以运行以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//运行以下代码, 观察输出情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> p[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><br><br>cout&lt;&lt;*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>]))&lt;&lt;endl;<br><br>cout&lt;&lt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&gt;&gt;<span class="hljs-number">8</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;((*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&gt;&gt;<span class="hljs-number">8</span>))&lt;&lt;endl;<br><br>cout&lt;&lt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-number">8</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;((*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-number">8</span>))&lt;&lt;endl;<br><br><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br> <br> cout&lt;&lt;(<span class="hljs-type">int</span>)p[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br> &#125;<br> cout&lt;&lt;endl;<br> &#125;<br> <br> <br>&#125;<br><br></code></pre></td></tr></table></figure><p>在x86架构下, 存储数据时, 是低字节存低位数, 高字节存高位数。例如<br><code>&#123;00,01,02,03&#125;</code>这个数据, 在计算机中按双字存时会显示为  <code>dd 3020100</code>, 因此, 对一个双字元素进行位移操作时, 要考虑端序的问题。  </p><h2 id="mixColumn"><a href="#mixColumn" class="headerlink" title="mixColumn"></a>mixColumn</h2><p>列混淆可以简单理解为, 将输入矩阵与一个混淆矩阵进行乘操作, 在加密时就乘加密矩阵, 解密时乘解密矩阵, 这里的加密矩阵和解密矩阵相乘会得到一个单位矩阵(单位矩阵就跟代数中的数字1是一样的)  </p><p><img src="/4Cc3.github.io/images/pasted-43.png" alt="加密矩阵与解密矩阵相乘"></p><p><img src="/4Cc3.github.io/images/pasted-44.png" alt="加密时进行的操作"></p><p><img src="/4Cc3.github.io/images/pasted-45.png" alt="解密时进行的操作"></p><p>这里的正矩阵和逆矩阵中的数字是标准AES提供的,一般也可以作为特征识别</p><p>只不过这里的乘操作稍微有些复杂, 并不是传统的矩阵乘法, 而是域上的乘法, 关于伽罗瓦域乘法的具体内容这里不展开讲, 因为过于复杂, 我们只需要了解如何进行伽罗瓦域上的乘法即可</p><p>首先, 使用输入矩阵乘加密矩阵相乘 </p><p><img src="/4Cc3.github.io/images/pasted-47.png" alt="求状态矩阵"></p><p>然后得到的状态矩阵可以用下图表示 </p><p><img src="/4Cc3.github.io/images/pasted-46.png" alt="状态矩阵表示"><br>这里用来连接每一项之间的运算符为伽罗瓦域乘法操作</p><p>这个矩阵中对应的行列其实和标准矩阵乘法的规则是一样的, 都是  </p><p>元素x在矩阵A所在的行中的每一个数字<br>乘<br>元素x在矩阵B所在的列中的每一个数字  </p><p>在伽罗瓦域上的加法是异或,乘法则是按照以下规则进行的  </p><p><img src="/4Cc3.github.io/images/pasted-48.png" alt="伽罗瓦域上的乘法">  </p><p>上面这个表达式的意思是, 对于一个8bit的二进制数来说, 如果它的最高位(也就是a7)为0, 那么就直接给他向左移一位就行了, 如果它的最高位是1, 那么就要把它和00011011进行一个异或(这里的00011011也是标准AES提供的, 其具体数值与加密矩阵和解密矩阵有关)  </p><p>而上图中给出的例子是进行了与0x02的乘法, 而这个与0x02的乘法也是最重要的, 因为所有的8bit数都可以拆成和若干个0x02和num相乘的异或式,</p><p>以00001101为例</p><p><img src="/4Cc3.github.io/images/pasted-49.png" alt="手写推导"></p><p>在上面的推导过程中,记num’为num这个数和2进行了一次伽罗瓦域乘,我们将其称为变换. </p><p>那么最终的结果就是进行了3次变化的num和进行了2次变化的num和没有进行变换的num相异或的形式.  </p><p>那么观察上面的推导式, 我们其实可以总结出一个规律, 我们将输入的byte记为num, 将进行运算的状态矩阵输入的byte记为mat, 那么对mat这个8bit数中的每一位进行从右到左的检测, 如果该位是0, 那么就说明需要对进行一次变化, 如果最低位是1, 那么就要将当前状态的num计入最终结果的异或式, 那么这么看来, 伽罗瓦域中的乘法就很好实现了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">GaloisMul</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mat, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ans = <span class="hljs-number">0</span>; <span class="hljs-comment">//最终组成的异或式的结果</span><br><span class="hljs-keyword">while</span> (mat)<br>&#123;<br><span class="hljs-comment">//如果当前mat的位数是1,那么就将当前状态的num计入最终的异或式</span><br><span class="hljs-keyword">if</span> (mat &amp; <span class="hljs-number">0x01</span>)<br>&#123;<br>ans ^= num;<br>&#125;<br><span class="hljs-comment">//Num_L右移一位，检测mat的下一位</span><br>mat &gt;&gt;= <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//如果当前mat的位数不是1, 那么就说明可以拆一个0x02出来, 那么就可以对式子进行化简, 将num*0x02进行合并, 也就是我们说的进行一次变换</span><br><span class="hljs-keyword">if</span> (num &amp; <span class="hljs-number">0x80</span>)<span class="hljs-comment">//如果num最高位为1</span><br>&#123;<br>num &lt;&lt;= <span class="hljs-number">1</span>;<br>num ^= <span class="hljs-number">0x1B</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>num &lt;&lt;= <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>将伽罗瓦域上的乘法搞定后, 就可以进行运算了, 前面也讲过, 在mixColumn的过程中, 会有两个矩阵, 分别是输入矩阵和给定的状态矩阵, 我们要将这两个矩阵进行域上的乘法来将他们合并, 所以最终的mixColumn的过程为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MixArray[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>] =<br>&#123;<br><span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>,<br><span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>,<br><span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>,<br><span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MixColum</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>(*PlainArray)[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//定义变量</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ArrayTemp[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">//初始化变量</span><br><span class="hljs-built_in">memcpy</span>(ArrayTemp, PlainArray, <span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//矩阵乘法 4*4</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br>PlainArray[i][j] =<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">0</span>], ArrayTemp[<span class="hljs-number">0</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">1</span>], ArrayTemp[<span class="hljs-number">1</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">2</span>], ArrayTemp[<span class="hljs-number">2</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">3</span>], ArrayTemp[<span class="hljs-number">3</span>][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>AES中的密钥是和加密单位矩阵同等规模的矩阵, 加密时输入的矩阵为4*4, 以byte为单位的矩阵, 那么AES最初的密钥也是这个规模  </p><p>当我们观察AES流程图时可以发现, 我们总共会进行十一轮密钥加, 并且每轮密钥加用的密钥都不一样, 但是我们最开始只用了一个16字节的密钥, 那么我们怎么才能搞到那么多的密钥呢, 这时就需要密钥生成算法来为后面几轮的密钥加提供密钥, 密钥生成的流程如下  </p><p>我们可以看到, 这里的密钥都是以列为单位的, 一列4个byte构成一个w, 4个w构成一个子密钥</p><p><img src="/4Cc3.github.io/images/pasted-50.png" alt="密钥生成流程图"></p><p>单另拿其中的一部分来看, 进行密钥生成的过程是这样的  </p><p><img src="/4Cc3.github.io/images/pasted-51.png" alt="密钥生成具体过程"></p><p>这里的g函数是将四个byte进行向左循环位移, 然后再逐字节进行S_box代换, 代换结束之后需要一个Rcon数组与新密钥的第一个byte进行一次异或</p><p>进行一轮生成后, 可以看到就生成了w4 w5 w6 w7这四组32位的串, 将他们连起来之后就是一个128位的新的密钥</p><h2 id="AES解密流程"><a href="#AES解密流程" class="headerlink" title="AES解密流程"></a>AES解密流程</h2><p><img src="/4Cc3.github.io/images/pasted-52.png" alt="解密流程图"></p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDA交叉引用</title>
    <link href="/4Cc3.github.io/2024/03/04/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/"/>
    <url>/4Cc3.github.io/2024/03/04/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="代码交叉引用"><a href="#代码交叉引用" class="headerlink" title="代码交叉引用"></a>代码交叉引用</h2><p>在IDA中, 指令转交控制权的方式叫做流, 在IDA中有三种流, 分别是普通流, 跳转流, 和调用流 </p><ol><li><p>普通流<br> 即为顺序执行,指令按照顺序执行就叫普通流  </p></li><li><p>调用流<br> 即为call这样的指令会被分配到一个调用流, 表示将控制权移交给目标函数, 一般情况下call指令也会被分配到一个普通流(在返回时会继续执行后面的指令)  </p></li><li><p>跳转流<br> 类似jmp jz jnz这样的指令会被分配到跳转流, 条件分支还会被分配一个普通流, 以在不进入分支的情况下继续执行代码.</p></li></ol><h2 id="数据交叉引用"><a href="#数据交叉引用" class="headerlink" title="数据交叉引用"></a>数据交叉引用</h2><p>在ida反汇编页面中, 数据的标题行显示的交叉引用的数量是有限制的, 可以在Options -&gt; General -&gt; Cross-reference -&gt; NUmber of displayed xrefs这个地方进行修改  </p><p>数据交叉引用分为三种  </p><ol><li><p>读取交叉引用<br> 在数据段中, ida会以<code>r</code>为结尾的后缀标注出数据引用 <img src="/4Cc3.github.io/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/image.png" alt="数据段反汇编"><br>在上图中, DATA XREF后面的标识的最后一位, 即为表示该数据交叉引用是什么类型的, main+E↑r这个引用就代表该引用是一个读取交叉引用</p></li><li><p>写入交叉引用, 后缀通常用w表示, 其代表有代码对改数据进行了写入操作  </p></li><li><p>偏移量交叉引用<br>其表示代码引用的是某个位置的地址(而非内容),其后缀为o, 例如全局数组的第一个地址, 或者是一个指针变量等. 偏移量交叉引用不一定是来自指令位置或数据位置, 其有可能来自程序数据部分.<br>例如C++中的虚函数, 如果一个函数是虚函数, 那么其标题行就会显示该函数与虚表的偏移量交叉引用. 并且构造函一般也会使用虚表的地址(如果有虚函数的话), 是可以通过虚表中的偏移量交叉引用找到构造函数的, 在c++中, 虚函数不会被直接引用, 肯定会通过虚表引用的</p></li></ol><h2 id="交叉引用列表"><a href="#交叉引用列表" class="headerlink" title="交叉引用列表"></a>交叉引用列表</h2><p>在subviews窗口中可以打开cross-references窗口, 就能看到完整的交叉引用列表了,当然也可以用快捷键<code>X</code>打开交叉引用窗口  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级C++基础</title>
    <link href="/4Cc3.github.io/2024/02/25/c-%E5%9F%BA%E7%A1%80/"/>
    <url>/4Cc3.github.io/2024/02/25/c-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>自从学了c++逆向之后我才发现原来我只会c with stl, 因此在这里记录一些高级c++的基础知识。  </p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-友元"><a href="#1-友元" class="headerlink" title="1. 友元"></a>1. 友元</h3><p>  友元函数可以访问类中的private和protect成员，声明友元函数只需要在类中添加<code>friend</code>关键字与待声明函数的原型, 例如现有如下函数原型:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br>```  <br>该函数是一个输出流运算符重载函数, 我们将他定义在类的外部, 但是这么做就会面临一个问题, 那就是无法输出类中的私有变量, 此时我们就需要对其添加友元属性:  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><br>  上述代码会在类中将重载函数定义为友元函数, 此时该函数就相当于Complex类中定义的函数了。</p><h3 id="2-构造函数与拷贝构造函数"><a href="#2-构造函数与拷贝构造函数" class="headerlink" title="2. 构造函数与拷贝构造函数"></a>2. 构造函数与拷贝构造函数</h3><p>构造函数的形式是  </p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">classname</span>&#123;<br><br>  <span class="hljs-title function_">classname</span>(<span class="hljs-params">typename</span> <span class="hljs-params">var</span>)&#123;<br>    <span class="hljs-comment">//code</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个东西是干啥的呢, 比如你有一个代码为<code>classname a=3.14</code>, 那么编译器就会报错, 因为它不知道怎么把一个浮点数赋值给classname, 所以这个时候就需要你在类中定义这么一个构造函数, 来指定赋值时发生的行为。需要注意的是，在声明了一个构造函数后，你的所有<code>=</code>运算符也自动被重载了， 即你想写<code>a=3.14;</code>时，不用额外再写个<code>classname operator=(typename var)&#123;&#125;</code>这么个东西了。</p><p>并且，所有的类在声明时会自动带一个构造函数，这个自带的构造函数是用来处理同类型变量的，假如你有一个classname类型的对象QAQ，那么你想在声明阶段声明一个classname类型的AWA，并且想把这个QAQ的初始值设置为和AWA一样，那么直接写<code>classname AWA=QAQ;</code>即可，不需要重新再写一个构造函数(赋值时也是一样的)，但是假如你想让这个过程发生一些额外的行为，例如你想让AWA等于两倍的QAQ再减一，你就需要对构造函数进行一下重构，编译器自动生成的构造函数只能单纯的进行一次拷贝。</p><p>如果一个构造函数没有参数, 那么在对象创建时会自动调用, 如果有参数, 那么就需要用<code>classname var(par);</code>这种语句。</p><p>在栈上创建对象时，实参位于对象名后面，例如<code>Student stu(&quot;小明&quot;, 15, 92.5f)；</code>在堆上创建对象时，实参位于类名后面，例如<code>new Student(&quot;李华&quot;, 16, 96);</code>。</p><p>构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处。</p><p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。  </p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//声明运算符重载</span><br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><br><br><span class="hljs-built_in">complex</span>(<span class="hljs-type">int</span> a)&#123;<br>m_real=<span class="hljs-number">0.0</span>,<br>m_imag=<span class="hljs-number">0.0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  complex a;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么此时编译器就会报错（因为类中包含了构造函数，而创建对象时却没有调用。），但是把构造函数删掉，编译器就会使用默认的构造函数，反而不会报错了。或者也可以自己手动再添加没有参数的构造函数：<code>complex()&#123;&#125;;</code></p><p>如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。</p><p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</p><p>最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。<code>complex a;</code>和<code>complex a();</code>是一样的。</p><p>拷贝构造函数的形式是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">T</span> (<span class="hljs-type">const</span> T&amp; other_obj)&#123;&#125;<br></code></pre></td></tr></table></figure><p>拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。构造函数的形参必须是引用，但不限制为const，但普遍来说会加上const限制。</p><p>为什么必须是当前类的引用呢？<br>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>为什么是 const 引用呢？<br>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p><p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p>拷贝构造函数会在以下三种情况中被调用:  </p><ol><li>用类的一个对象去初始化类的另一个对象时  </li><li>如果函数的形参是类的对象, 调用函数时, 进行形参和实参结合(实参是caller传入的东西, 形参是放在寄存器或栈上的, callee分配的东西)</li><li>如果函数的返回值是类的对象, 函数执行完成返回时(返回时, callee会将要返回的对象拷贝给一个临时变量, 然后销毁callee中的对象, 回到caller的位置再将对象当做返回值返回)</li></ol><h3 id="3-初始化列表"><a href="#3-初始化列表" class="headerlink" title="3. 初始化列表"></a>3. 初始化列表</h3><p>  在写构造函数时, 不仅可以将成员变量在构造函数的函数体中赋值, 也可以将成员变量用初始化列表赋值, 初始化列表的书写方法如下:  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><span class="hljs-built_in">complex</span>()&#123;<br>  m_real=<span class="hljs-number">0.0</span>,<br>  m_imag=<span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  上述代码中, 两个构造函数的功能类似, 但是采取了两个不同的写法, 第一个构造函数在函数声明和函数体之间多了一个冒号和一个用逗号连接的列表, 具体用法是<code>变量名(表达式)[,变量名(表达式)...]</code><br>  该语句等价于 <code>变量名=表达式</code></p><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>C++中的引用(reference)使用符号”&amp;”表示, 这个东西看着和C中的取地址符是同一个符号, 但是这两个的作用却不相同, 在C++中引用相当于是一个变量的别名, 使用引用定义的变量和其原变量没有任何区别。  </p><p>例如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> la;<br><span class="hljs-type">int</span> &amp;a = la;<br></code></pre></td></tr></table></figure><p>使用该定义, 则变量a就是la, 操作a和操作la是一样的, c++在编译时会自动进行优化, 对a的所有操作都会变成直接对la的操作。</p><p>引用的应用有以下几点：</p><h3 id="1-做为函数参数"><a href="#1-做为函数参数" class="headerlink" title="1. 做为函数参数"></a>1. 做为函数参数</h3><p>在当做参数时，应用的参数可以直接操作传入的数字，而不是操作传入参数的拷贝<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>a+=<span class="hljs-number">0xcafe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_pointer</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span></span>&#123;<br>*a+=<span class="hljs-number">0xfe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_ref</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;<br>  a+=<span class="hljs-number">0xca</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">hello</span>(a);<br>  <span class="hljs-built_in">hello_pointer</span>(&amp;a);<br>  <span class="hljs-built_in">hello_ref</span>(a);<br>&#125;    <br><br></code></pre></td></tr></table></figure></p><p>上面的三个函数的反编译结果分别是</p>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; void __fastcall hello()</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               <span class="hljs-meta">public</span> _Z5helloi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               _Z5helloi proc <span class="hljs-built_in">near</span>                     <span class="hljs-comment">; CODE XREF: main+19↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               arg_0= <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001531</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001534</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                      <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001537</span> <span class="hljs-number">81</span> <span class="hljs-number">45</span> <span class="hljs-number">10</span> FE CA <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">add</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-number">0CAFEh</span><br><span class="hljs-symbol">.text:</span>000000014000153E <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000153F <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span>                               _Z5helloi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br></code></pre></td></tr></table></figure><p>hello 这个函数中, ecx中存放参数, 可见函数中新建了一个变量arg_0用来存放参数, 说明函数调用的参数是一个拷贝<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; int *__fastcall hello_pointer(int *)</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               <span class="hljs-meta">public</span> _Z13hello_pointerPi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               _Z13hello_pointerPi proc <span class="hljs-built_in">near</span>           <span class="hljs-comment">; CODE XREF: main+25↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001542</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001545</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001549</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000154D</span> 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000154F <span class="hljs-number">8D</span> <span class="hljs-number">90</span> FE <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0FEh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001555</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001559</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span>000000014000155B <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000155C <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span>                               _Z13hello_pointerPi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br></code></pre></td></tr></table></figure></p><p>  hello_pointer函数中, rcx是调用变量的地址, 而寻址后改变的是传入的原变量,能够起到改变传入的变量的效果  </p>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">          <span class="hljs-keyword">int</span> *__fastcall hello_ref(<span class="hljs-keyword">int</span> *)<br><span class="hljs-symbol">.text:</span>000000014000155E                               <span class="hljs-meta">public</span> _Z9hello_refRi<br><span class="hljs-symbol">.text:</span>000000014000155E                               _Z9hello_refRi proc <span class="hljs-built_in">near</span>                <span class="hljs-comment">; CODE XREF: main+31↓p</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; DATA XREF: .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; .pdata:0000000140005084↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000155F <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001562</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001566</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span>000000014000156A 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000156C <span class="hljs-number">8D</span> <span class="hljs-number">90</span> CA <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0CAh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001572</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001576</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001578</span> <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001579</span> <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000157A C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span>000000014000157A<br><span class="hljs-symbol">.text:</span>000000014000157A                               _Z9hello_refRi endp<br><br></code></pre></td></tr></table></figure><p>  而hello_ref函数传参是一个引用, 观察代码, 可以发现, 使用引用和使用指针传参是同样的效果,代码完全相同, 这就说明引用其实是编辑器代替你操作指针, 只不过使用引用将会减少代码量并提高代码可读性。  </p><p>指针与引用的区别：</p><ul><li>指针是可以独立存在的; 但是引用不行</li><li>引用必须要进行初始化，指针没有必要</li><li>指针可以设置为NULL， 但是引用不行</li><li>引用一旦进行初始化之后，不会再改变其指向；但指针可以</li></ul><h3 id="2-引用作为函数的返回值"><a href="#2-引用作为函数的返回值" class="headerlink" title="2. 引用作为函数的返回值"></a>2. 引用作为函数的返回值</h3><p>  语法：类型 &amp;函数名（形参列表）{ 函数体 }<br>  1.引用作为函数的返回值时，必须在定义函数时在函数名前加&amp;<br>  2.用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本</p><p>  例如:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">10</span>;<span class="hljs-comment">// 若func的返回值是一个生命周期大于func的变量时</span><br><span class="hljs-type">int</span> &amp;a = <span class="hljs-built_in">func</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="1-重载一般运算符"><a href="#1-重载一般运算符" class="headerlink" title="1. 重载一般运算符"></a>1. 重载一般运算符</h3><p>  这里的一般运算符指普通的二元运算符, 例如加减乘除<br>  以下列程序为例:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br>  <span class="hljs-built_in">complex</span>()&#123;<br>    m_real=<span class="hljs-number">0.0</span>,<br>    m_imag=<span class="hljs-number">0.0</span>;<br>  &#125;<br><br><br>  complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A) <span class="hljs-type">const</span>&#123;<br>    complex B;<br>    B.m_real = <span class="hljs-keyword">this</span>-&gt;m_real + A.m_real;<br>    B.m_imag = <span class="hljs-keyword">this</span>-&gt;m_imag + A.m_imag;<br>    <span class="hljs-keyword">return</span> B;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">complex::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  cout&lt;&lt;m_real&lt;&lt;<span class="hljs-string">&quot; + &quot;</span>&lt;&lt;m_imag&lt;&lt;<span class="hljs-string">&quot;i&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">4.3</span>, <span class="hljs-number">5.8</span>)</span></span>;<br>  <span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2.4</span>, <span class="hljs-number">3.7</span>)</span></span>;<br>  complex c3;<br>  c3 = c1 + c2;<br>  c3.<span class="hljs-built_in">display</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  仔细观察上面的程序, 我们在 complex 类中重载了运算符+，该重载只对 complex 对象有效, 当执行c3 &#x3D; c1 + c2;语句时，编译器检测到+号左边（+号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数operator+()，也就是转换为下面的形式：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3 = c1.<span class="hljs-keyword">operator</span>+(c2);<br></code></pre></td></tr></table></figure><br>  c1 是要调用函数的对象，c2 是函数的实参。<br>  当然, 上述写法是重载了一个成员函数, 对于运算符的重载也可以变为全局重载:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A, <span class="hljs-type">const</span> complex &amp;B)&#123;<br>  complex C;<br>  C.m_real = A.m_real + B.m_real;<br>  C.m_imag = A.m_imag + B.m_imag;<br>  <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><br>  当编译器检测到调用时,例如 <strong>c3&#x3D;c1+c2</strong> 加号两边都是complex类型的变量, 那么编译器就会使用如下的调用<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3=<span class="hljs-keyword">operator</span>+(c1,c2);<br></code></pre></td></tr></table></figure><br>  <font size=5>将运算符重载函数作为类的成员函数时，二元运算符的参数只有<strong>一个</strong>，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的,默认就是this。</font>  </p><h3 id="2-输入输出流运算符重载"><a href="#2-输入输出流运算符重载" class="headerlink" title="2. 输入输出流运算符重载"></a>2. 输入输出流运算符重载</h3><p>  一般来说, 这类运算符都是在类外部借用友元函数重载的, 具体原因是因为如果在类内部重载, 那么就需要先将对象实例化, 再通过对象来调用运算符, 例如<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Distance</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> feet;             <span class="hljs-comment">// 0 到无穷</span><br>        <span class="hljs-type">int</span> inches;           <span class="hljs-comment">// 0 到 12</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 所需的构造函数</span><br>        <span class="hljs-built_in">Distance</span>()&#123;<br>            feet = <span class="hljs-number">0</span>;<br>            inches = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">Distance</span>(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> i)&#123;<br>            feet = f;<br>            inches = i;<br>        &#125;<br>        ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp; os)<br>        &#123;<br>            os&lt;&lt;<span class="hljs-string">&quot;英寸：&quot;</span>&lt;&lt;feet&lt;&lt;<span class="hljs-string">&quot;\n英尺：&quot;</span>&lt;&lt;inches;<br>            <span class="hljs-keyword">return</span> os;<br>        &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Distance <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>)</span></span>;<br>    d1&lt;&lt;cout;<span class="hljs-comment">//相当于d1.operator&lt;&lt;(cout)</span><br>&#125;<br>```  <br>这里的就是通过成员函数进行声明, 在使用时, 运算符左值必须为对象。     <br>若不使用成员函数进行重载， 那么就该使用<span class="hljs-keyword">friend</span>关键字先在类中声明函数为友元函数  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out , complex a);<br>  ...<br><br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  而返回一个ostream的对象的原因是方便其可以在返回后继续进行输出or输入, 函数的定义也可以看到返回的是一个ostream类型的引用。而这个第一个参数其实是cout这个对象，而cout是在std中定义的对象。  </p><h3 id="3-重载-运算符"><a href="#3-重载-运算符" class="headerlink" title="3. 重载[]运算符"></a>3. 重载[]运算符</h3><p>  C++ 规定，下标运算符[ ]必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：<code>返回值类型 &amp; operator[ ] (参数);</code></p><p>  或者：<code>const 返回值类型 &amp; operator[ ] (参数) const; </code></p><p>  使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。</p><h3 id="4-重载-运算符"><a href="#4-重载-运算符" class="headerlink" title="4. 重载++ --运算符"></a>4. 重载++ --运算符</h3><p>  这两个都是一元运算符，重载方式如下：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>++()&#123;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<span class="hljs-comment">//++i</span><br><br>complex <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n)&#123;<br>  complex s = *<span class="hljs-keyword">this</span>;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<span class="hljs-comment">//i++</span><br></code></pre></td></tr></table></figure><br>  可以看到, 返回值是表达式的结果(基本上所有运算符重载的返回值都是表达式的结果)  </p><p>  而前自增和后自增的区别为是否传参, 后自增的参数<code>int n</code>没有任何意义</p><h3 id="5-C-重载-（强制类型转换运算符）"><a href="#5-C-重载-（强制类型转换运算符）" class="headerlink" title="5. C++重载()（强制类型转换运算符）"></a>5. C++重载()（强制类型转换运算符）</h3><p>在 C++ 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。</p><p>  类型强制转换运算符是单目运算符，也可以被重载，但只能<em>重载为成员函数</em>，<em>不能重载为全局函数</em>。经过适当重载后，<code>(类型名)对象</code>这个对对象进行强制类型转换的表达式就等价于<code>对象.operator 类型名()</code>，即变成对运算符函数的调用。</p><p>  对类型转化定义过的函数，编译器会在需要时自动调用，例如  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>...<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> real; &#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这个函数就对double()这个强制转换进行了定义, 需要注意的是, <em>对double运算符重载不需要指定返回类型</em>, 因为返回类型就是重载运算符本身代表的类型, 即为double</p><p>  定义之后, 在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Complex <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>)</span></span>;<br>cout &lt;&lt; (<span class="hljs-type">double</span>)c &lt;&lt; endl;  <span class="hljs-comment">//输出 1.2</span><br><span class="hljs-type">double</span> n = <span class="hljs-number">2</span> + c;  <span class="hljs-comment">//等价于 double n = 2 + c. operator double()</span><br>cout &lt;&lt; n;  <span class="hljs-comment">//输出 3.2</span><br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-C-const相关"><a href="#1-C-const相关" class="headerlink" title="1. C++ const相关"></a>1. C++ const相关</h3><ul><li><p>const成员变量  </p><p>const成员变量非常好定义, 只需要在定义时在最前面加上const关键字即可, 定义为const的变量无法更改其值  </p></li><li><p>const成员函数  </p><p>常成员函数的定义方法为在函数的最后加一个const关键字, 例如:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Student::getage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">return</span> m_age;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码中, getage函数加了const关键字, 那么其对所有成员变量的访问权限就变为了只读<br>需要注意的是, 加了const的和不加const的函数是两个完全不同的函数原型。<br>还有需要注意的事是，如果const关键字被加在了一个函数的最开头， 那么就说明该函数的返回值是一个常量， 不允许修改其返回值  </p></li><li><p>常对象<br>  定义常对象的语法和定义常量的语法类似：          </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-type">const</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br></code></pre></td></tr></table></figure><p> class为类名，object为对象名，params为实参列表， p为指针名。两种方式定义出来的对象都是常对象。 </p><p> 一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</p></li></ul><h2 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2. static关键字"></a>2. static关键字</h2><p>  声明为static的变量会存储在bss段或者data段，而不是在栈中，因此当一个函数的执行周期结束后并不会被释放掉，同时static不会破坏类的封装性，类外不能访问protect和private的变量。</p>]]></content>
    
    
    <categories>
      
      <category>C++编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++逆向工程</title>
    <link href="/4Cc3.github.io/2024/02/24/C-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/4Cc3.github.io/2024/02/24/C-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="C-逆向工程基础"><a href="#C-逆向工程基础" class="headerlink" title="C++逆向工程基础"></a>C++逆向工程基础</h2><p>在之前的文章中讲过了调用约定相关的知识, 这里就不在赘述, 阅读之前需要重点回顾一下thiscall和cdecl这两个调用约定  </p><h3 id="1-this指针"><a href="#1-this指针" class="headerlink" title="1. this指针"></a>1. this指针</h3><p>所有静态(public的)的c++成员函数都使用this指针, this都被初始化, 指向用于调用成员函数的对象, 例如  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">obj1.<span class="hljs-built_in">func</span>()<br>obj2.<span class="hljs-built_in">func</span>()<br>p_obj-&gt;<span class="hljs-built_in">func</span>()<br></code></pre></td></tr></table></figure><p>上面的三次调用func的过程中, this分别指&amp;obj1, &amp;obj2,  &amp;p_obj  , 微软的thiscall调用约定会将this传递到ECX寄存器中, 而GNU g++的编译器的cdecl调用约定会把this当作成员函数的第一个参数, 一般是最后一个压入栈中的。<br>以菜鸟教程中关于c++多态的实例代码为例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//code number: 001</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> width, height;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Shape</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>)<br>    &#123;<br>        width = a;<br>        height = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">Shape</span>(a, b) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> (width * height); <br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Triangle</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">Shape</span>(a, b) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> (width * height / <span class="hljs-number">2</span>); <br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 程序的主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>    Shape *shape;<br>    <span class="hljs-function">Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">7</span>)</span></span>;<br>    <span class="hljs-function">Triangle  <span class="hljs-title">tri</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 存储矩形的地址</span><br>shape = &amp;rec;<br><span class="hljs-comment">// 调用矩形的求面积函数 area</span><br>shape-&gt;<span class="hljs-built_in">area</span>();<br><br><span class="hljs-comment">// 存储三角形的地址</span><br>shape = &amp;tri;<br><span class="hljs-comment">// 调用三角形的求面积函数 area</span><br>shape-&gt;<span class="hljs-built_in">area</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该代码编译完成之后, 在ida中反编译的结果如下:  </p><p><img src="/4Cc3.github.io/images/pasted-36.png" alt="IDA反编译的伪代码">  </p><p>可以看到, 其中圈出来的部分v5 v4分别就是源代码中声明的变量的指针, 在调用成员函数时, 函数的第一项参数都是指向实例化后的对象的指针。 </p><h3 id="2-如何理解多态"><a href="#2-如何理解多态" class="headerlink" title="2. 如何理解多态"></a>2. 如何理解多态</h3><p>在c++中存在多态的概念, 此处还是以code 001为例, 当我们编译code 001时, 会发现其输出为  </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Parent class area :<br>Parent class area :<br></code></pre></td></tr></table></figure><p>&emsp;这并不是我们期望的输出, 我们的期望输出是:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Rectangle class area :<br>Triangle class area :<br></code></pre></td></tr></table></figure><p>&emsp;这种情况下, 就需要使用到c++中的多态概念, 即:相同名称行使不同功能。<br>&emsp;那么这种情况是怎么发生的呢？ 这里就需要理解两个概念 <strong>早绑定</strong> 和<strong>延迟绑定</strong>。<br><br>&emsp;首先， 绑定的概念是将符号变更为地址， 那么code 001 在编译时，其就会将里面的函数符号更换为地址，因为shape是一个已经声明过的变量，所以编译器会自动推理其类型， 为后面该变量所调用的成员函数进行绑定，那么此时绑定的函数都是Shape这个类的成员函数，因此所有的area函数都将是Shape这个类中的函数。<br>&emsp;如果为成员函数添加了virtual关键字，那么其就会通过虚表进行延后绑定。</p><h3 id="3-虚函数和虚表"><a href="#3-虚函数和虚表" class="headerlink" title="3. 虚函数和虚表"></a>3. 虚函数和虚表</h3><p>&emsp;虚函数在c++中实现多态。编译器在编译源代码时，编译器会为每一个包含虚函数的类生成一个表，其中包含<strong>指向每一个虚函数的指针</strong>。该表就叫虚表(vtable)。除此之外，编译器会为每一个类添加一个额外的成员变量，成为虚表指针(vtable pointer), 该指针会在适当的时候（一般是在运行创建对象的实例时）指向虚表，并且其是类的第一个成员变量。拿以下程序为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//code number: 002</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func5</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>&emsp;在上述程序中,B是A的一个子类, B中有5个虚函数(其中func1是A中的函数, 在B中对其进行了重构,并且B中多了一个函数func5, 所以B总共有5个虚函数)同时，A中存在一个纯虚函数，这就说明func1必须这种子类中进行重写，否则无法创建B的实例。<br>&emsp;在上面的程序中，看起来似乎A中存在两个数据成员，B有三个数据成员，实际上A有三个，B有四个， 因为其中包含一个虚表指针，虚表指针是两个类的第一个数据成员， 是编译器添加上去的<br><img src="/4Cc3.github.io/images/pasted-35.png" alt="虚表布局"><br>&emsp;像上面的布局，虚表有两个，分别是class A的和class B的，由于B中对func1和func5进行了重写, 所以B的虚表中的func1和func5都是B的函数地址,而其它没有在b中重写的函数则直接引用A的函数地址。<br>由于没有对纯虚函数func1进行实现,所以A的虚表中并没有func1的地址, 此时, 编译器会插入一个处理错误的函数的地址, 名为purecall, 这个函数理论上不会被调用, 其会令程序终止运行。  </p><p><img src="/4Cc3.github.io/images/pasted-37.png" alt="示例代码">  </p><p>对于上述代码, 调用了一个名为vfunc3的虚函数, 由于声明时声明的对象是A类型的, 但是实际上对象是B类型的对象, 所以在调用函数vfunc3时应该也要调用B对象的func3, 那么此时编译器就会使用虚表机制。</p><p>首先要将第虚表指针读出（结构体的第一个参数， 即为1处的eax），然后根据edx+8（即为寻址）来找到vfunc3的地址，然后再执行  </p><p>那么根据前面的代码，可以定义以下结构体  </p><p><img src="/4Cc3.github.io/images/pasted-38.png" alt="自定义结构体">  </p><p>此时, 再将虚表引用操作重新格式化后就会变成<code>mov eax, [edx+B_vtable.vfunc3]</code>  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA中创建结构体</title>
    <link href="/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h2 id="IDA中的结构体"><a href="#IDA中的结构体" class="headerlink" title="IDA中的结构体"></a>IDA中的结构体</h2><p>在IDA中, 遇见的结构体有以下四种情况:全局变量的结构体(定义在全局的变量), 创建在栈上的结构体(局部变量), 创建在堆上的结构体(使用malloc函数分配空间的指针), 结构体数组。  </p><p>*<br>对于声明在全局的结构体，编译器在编译时可以计算出每个成员的地址，不必进行任何计算， 所以声明在全局的结构题在反编译时看起来与没有声明结构体是一样的，乍一看很像一堆全局变量。  </p><ul><li><p>对于分配在栈上的结构体， 访问其成员变量页不需要任何计算， 编译器可以直接访问到每个字段的相对偏移量， 在这种情况下， 乍一看很像一堆局部变量</p></li><li><p>分配在堆上的结构体，就是先声明一个该结构体的指针， 然后在通过malloc函数为其分配空间，这种东西就没有办法通过在ida中创建结构体来恢复其在程序中应用的符号了，只能通过观察其在栈堆中的分配和操作来理解该结构体  </p></li><li><p>结构体数组唯一要注意的点是分配在堆上的结构体数组，此时malloc的参数可能是结构体大小的某一个倍数，而不是整个结构体的大小</p></li></ul><h2 id="创建IDA结构体"><a href="#创建IDA结构体" class="headerlink" title="创建IDA结构体"></a>创建IDA结构体</h2><p>在view -&gt; open subviews -&gt; structures中可以打开结构体窗口, 其中标蓝的是ida找到的结构体, 下图中框起来的是IDA告诉你,你可以执行的操作的快捷键。    </p><p><img src="/4Cc3.github.io/images/pasted-31.png" alt="IDA中的结体窗口"></p><p>同样，在view -&gt; open subviews -&gt; local types中就可以打开已经存在的变量类型， 如果你在suructers窗口中创建了结构体，那么就可以在本窗口中找到。选中需要编辑的变量类型， 按右键-&gt; edit(快捷键ctrl + E)就可以在本窗口中按照c语言风格来声明结构体中的成员变量了。  </p><p><img src="/4Cc3.github.io/images/pasted-32.png" alt="编辑结构体"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA中的数组</title>
    <link href="/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <url>/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="在IDA中的数据类型"><a href="#在IDA中的数据类型" class="headerlink" title="在IDA中的数据类型"></a>在IDA中的数据类型</h2><p>数组是最简单的复合数据结构, 传统意义的数组是包含同一数据类型的连续元素组成的内存块, 也就是说, 数组实际上就是一段内存块的集合。 </p><p>而在c语言中，我们都熟知的一个东西就是数据类型， 而在计算机底层的概念中，数据类型是一个抽象的概念， 其本质是对一段内存布局中读写数据的长度。  </p><p>举例来说， 对于c语言中的int类型，其在x86中的长度是四个字节，也就是说计算机如果想读取一个int类型的数据，就要连续的读取四个字节才能正确的表示一个int类型的数  </p><p><img src="/4Cc3.github.io/images/pasted-24.png" alt="内存中存储一个int变量">  </p><p>如图所示, 如果在c语言中声明 <em>int a&#x3D;1</em>, 那么在程序编译完成后就会按照上图的形式存储。  </p><p>显然，ida并没有正确识别出其数据类型，这是因为编译器剥离了符号，但是经验丰富的逆向工程师是能够识别出这个变量实际上是一个32位整数。  </p><p>因此，逆向工程师会选择选中该数据，按快捷键d来改变其数据类型，对于那些更加了解ida的逆向工程师来说，他们可能更加乐意在option -&gt; set up datatypes(快捷键Alt + D) 中更改数据类型。</p><h2 id="在IDA中创建数组"><a href="#在IDA中创建数组" class="headerlink" title="在IDA中创建数组"></a>在IDA中创建数组</h2><p>在IDA中，你可以在Edit -&gt; Array中创建数组。在IDA中创建数组的默认大小是根据创建数组的第一个元素的长度决定的，例如创建数组的第一个元素的长度是4字节，那么之后所有的元素长度都是4字节，所以更改好第一个元素的长度很重要，其次就是要填好Array Size，这个代表数组的长度是多少，有几个元素这里就填几  </p><p><img src="/4Cc3.github.io/images/pasted-25.png" alt="IDA创建数组对话框">  </p><p>其中有几个选项这里简单介绍一下  </p><ul><li><p>Array Size: 创建数组的长度  </p></li><li><p>Item on a line: 一行显示的数组的长度</p></li><li><p>Element print width: 打印数组时的宽度, 这里指的是显示的宽度, 指定宽度后数据将在指定范围内显示  </p></li><li><p>use “dup” construct: 是否使用dup将重复的数据折叠  </p></li><li><p>signed element : 是否使用有符号元素  </p></li><li><p>display index： 该选项会在伪代码窗口中将元素按照数组的形式显示</p></li></ul><p>这里创建数组时需要自己对反编译的结果进行识别, <strong>gcc编译器在编译时, 如果一个数组并没有过用变量访问数组中的元素时（例如a[i]这种访问方式，只用过a[1]这种常量当访问下标）, 编译器就会对其进行优化, 使得ida无法正确识别出这一串数据是一个数组, 所以需要自己创建数组</strong>, 例如以下程序:  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int a<span class="hljs-comment">[17]</span>=&#123;1,2,3,4&#125;;<br>int main()&#123;<br>a<span class="hljs-comment">[0]</span>+=11;<br>a<span class="hljs-comment">[2]</span>+=12;<br>a<span class="hljs-comment">[17]</span>=18;<br>a<span class="hljs-comment">[16]</span>=20;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序在编译完成并剥离符号表后, 会变成下面这个样子  </p><p><img src="/4Cc3.github.io/images/pasted-27.png" alt="IDA伪代码视图"></p><p><img src="/4Cc3.github.io/images/pasted-28.png" alt="IDA反汇编视图"></p><p>这里选中第一个元素,将其转化位dd(第二个d是double word的意思), 计算下数组长度(源代码中是a[17], 这里数组长度就填18), 然后创建数组, 就可以生成一个数组了。</p><p>可以看到, 在反汇编窗口中并不能直观的看出这段数据是一个数组, 并且还多了一些东西, 初步估计是编辑器为了防止内存溢出设置的缓冲区域  </p><p><img src="/4Cc3.github.io/images/pasted-29.png" alt="编译完成后,数组前后会多出20h个字节的区域"></p><p><img src="/4Cc3.github.io/images/pasted-30.png" alt="成功创建数组后的ida中伪代码视图"></p><p>至此, 就成功创建了一个数组, 后面再进行逆向分析都会容易很多。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手册: IDA使用</title>
    <link href="/4Cc3.github.io/2024/02/20/%E6%89%8B%E5%86%8C-IDA%E4%BD%BF%E7%94%A8/"/>
    <url>/4Cc3.github.io/2024/02/20/%E6%89%8B%E5%86%8C-IDA%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>文本搜索: Search -&gt; Text(Alt + T)启动文本搜索，可以用于搜索一个完整的词，按ctfl + T就可以重复前一项搜索，匹配下一项结果。  </p><p>二进制搜索： serach -&gt; squence of bytes(ALT + B)即可启动二进制搜索。其可以搜索一个二进制字节序列，以空格分隔，按ctfl + T就可以重复前一项搜索，匹配下一项结果。如果想要搜索内嵌字符串（即十六进制种ASCII字符串），则需要讲搜索字符串用引号括起来 。如果想要搜索操作码序列而不是ASCII文本时，记得勾选Case sensitive，不然会出现匹配到无关结果。</p><p>函数: 从Edit -&gt; function 中即可进行创建函数, 删除函数等操作, 按快捷键c可以将一段十六机制数识别为代码</p><p>数组: 在Edit -&gt; Array中打开创建数组对话框, 如果指定位置的第一个数据项已经被定义, 那么直接按右键,在弹出的上下文菜单中就会显示Array选项, 创建的数组的元素的类型由第一个元素的类型决定  </p><h2 id="ida显示设置"><a href="#ida显示设置" class="headerlink" title="ida显示设置:##"></a>ida显示设置:##</h2><ul><li><p>栈指针: general -&gt; option -&gt;disassembly-&gt;勾选stack pointer 即可在ida中显示函数中的栈指针的相对值<br><img src="/4Cc3.github.io/images/pasted-21.png" alt="栈指针开启后的效果">  </p></li><li><p>一行中显示字节码的数量<br><img src="/4Cc3.github.io/images/pasted-22.png" alt="选择一行中可显示的字节码数量"> </p></li><li><p>更改数据类型<br>options -&gt; setup data types  中打开对话框<br><img src="/4Cc3.github.io/images/pasted-23.png" alt="指定数据大小"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈帧</title>
    <link href="/4Cc3.github.io/2024/02/20/%E6%A0%88%E5%B8%A7/"/>
    <url>/4Cc3.github.io/2024/02/20/%E6%A0%88%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<p>以下面的程序为例  </p><p><img src="/4Cc3.github.io/images/pasted-16.png" alt="示例函数"></p><p>demo_stackframe函数调用了一个bar函数, 并且demo_stackframe函数自身还包含三个参数和几个局部变量, 那么在调用demo_stackframe函数时就会产生一个栈帧, 该栈帧长下面这个样子  </p><p><img src="/4Cc3.github.io/images/pasted-17.png" alt="基于ESP的栈帧">  </p><p>这个是基于ESP的栈帧, 它包含了abc三个参数(在调用demo_stackframe时产生的), 一个eip,(用于确定demo_stackframe返回时的地址)四个局部变量。那么对于该栈帧来说， 想要调用其中一个局部变量就可以使用偏移的方式来调用，例如[esp+4]就代表调用y这个变量 ，但是基于ESP的栈帧有个坏处， 那就是在demo_stackframe中调用函数bar的时候， 会用到push来将bar函数需要用到的函数压入栈中，而push又会改变esp的位置， 所以会产生一些混乱的情况 ，例如：</p><p><img src="/4Cc3.github.io/images/pasted-18.png" alt="示例代码">  </p><p>上面的1 和 2 处虽然都是esp+4，但是却代表不同参数，所以说不是很好看，为了解决这个问题， x86提供了一个名为EBP的寄存器专门用来存栈帧指针， 啥意思呢？  </p><p>简单来说， EBP这个寄存器中存储的是进入到被调用函数时，ESP的位置。</p><p><img src="/4Cc3.github.io/images/pasted-19.png" alt="基于EBP的栈帧">  </p><p>像上面这个图， 相较于基于ESP的栈帧多了一个saved ebp， 这个是因为stdcall和cdecl都要求函数只能动EAX，ECX和EDX，别的寄存器都不能动，（因此其它寄存器都被称为被保护寄存器）<br>所以要想使用EBX，就必须先把EBX的值存下来，然后在用完EBX之后再把值存回去</p><p>在使用基于EBP的栈帧时，调用者需要执行以下代码  </p><p><img src="/4Cc3.github.io/images/pasted-20.png" alt="示例代码">  </p><p>也就是说，EBP指向的其实就是自己原先的值的位置，而在EBP之下的东西（栈是向下生长的）都是局部变量，或者是其它被调用函数的东西，我们不是很关心， 我们只需要知道， 在本函数执行完毕时，直接将ESP放到EBP的位置上就可以释放所有局部变量， 并且基于EBP的栈帧的所有变量的偏移值都是不会变的。</p><p>执行完demo_stackframe毕之后， 只需要 </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><span class="hljs-comment">;直接清除掉了所有局部变量</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span> <span class="hljs-comment">;恢复ebp最开始的值</span><br><span class="hljs-keyword">ret</span>     <span class="hljs-comment">;回到调用demo_stackframe的那个call语句的下面那一条语句, 等价于弹出栈中的saved eip, 然后跳转到eip的位置</span><br></code></pre></td></tr></table></figure><p>当然, 上述指令被x86简化了, 其提供了一个leave指令 </p><pre><code class="hljs">leaveret</code></pre><p>leave指令执行将esp释放到栈帧最开始的位置(也就是ebp指的位置),以达到清除全部临时变量的效果, 然后再恢复ebp最开始的值。  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调用约定</title>
    <link href="/4Cc3.github.io/2024/02/20/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/4Cc3.github.io/2024/02/20/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>调用约定是指程序在调用函数时的规则，例如参数入栈的顺序，返回值的位置等。  </p><h2 id="C调用约定（-cdecl）"><a href="#C调用约定（-cdecl）" class="headerlink" title="C调用约定（_cdecl）"></a>C调用约定（_cdecl）</h2><p>_cdecl是x86体系中c编译器使用的默认调用约定，其要求函数参数按照从右往左的顺序入栈， 这样就能使第一个参数永远放在栈顶  </p><p> 同时，该约定还要求函数的参数如果放在了栈中， 那么就需要由调用者（caller）函数将参数压栈，并且在返回时将栈指针恢复（即恢复esp的位置）  </p><p>例如：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">call</span> func<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">16</span><br><br></code></pre></td></tr></table></figure><p>当然也有不改变esp的情况， 例如  </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">12</span>],<span class="hljs-number">4</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">8</span>],<span class="hljs-number">3</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>],<span class="hljs-number">2</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>],<span class="hljs-number">1</span><br><span class="hljs-keyword">call</span> func<br><br></code></pre></td></tr></table></figure><p>像上面的函数没有改变esp的位置, 所以不需要再次调整esp, 可以直接执行下一条指令  </p><h2 id="标准调用约定-stdcall"><a href="#标准调用约定-stdcall" class="headerlink" title="标准调用约定(_stdcall)"></a>标准调用约定(_stdcall)</h2><p>该约定为微软定义, 其参数的入栈顺序也为从右到左, 但是该约定在函数结束执行时, 由被调用者(callee)函数删除栈中的参数。这种方式相对于cdecl来说， 被调用者函数如果接受的是一个变长参数， 那么被调用函数就不知道自己接受的参数到底有多长，所以stdcall不支持变长参数的函数（例如printf）</p><p>x86编译器会使用ret指令的一种特殊形式来实现上述过程， 即为 <strong>ret [imm]</strong> (imm为一个立即数) 该指令在返回时（回到调用本函数的call指令下面一条指令）时会顺便给栈指针加上这个立即数， 即为从栈中释放imm个字节的空间</p><p>书上说这种调用约定的优点是不需要通过代码从栈中清除参数， 因此该调用约定会稍微快一些（实际上我感觉作用微乎其微， 除非能够在硬件层面上ret imm这种指令要比add这个指令快）  </p><h2 id="x86-fastcall约定"><a href="#x86-fastcall约定" class="headerlink" title="x86 fastcall约定"></a>x86 fastcall约定</h2><p>fastcall是stdcall的一个变体， 它的意思是向寄存器传参，而不是向栈传参，当然学过计算机系统的小伙伴会知道， 程序一般是不把参数放在栈里的， 大多数函数都是将参数放在寄存器中， 只有参数大于七个的时候程序才会考虑优化， 将参数放在栈中。</p><p>而本约定与上述情况类似， 但是fastcall约定函数向寄存器最多传递两个参数， 并且将前两个参数分别放在ECX和EDX寄存器中， 而其他的参数则更stdcall一样， 将参数从右到左压入栈中，并且由被调用者清除参数。</p><h2 id="C-调用约定"><a href="#C-调用约定" class="headerlink" title="C++调用约定"></a>C++调用约定</h2><p>C++有类这么个东西， 它会需要用到this指针（this指向实例化过后的对象）， 如果一个类中包含一个成员函数，并且该函数为非静态成员函数（public的），那么实例化过后的对象在调用这个函数时， this指针就应该指向这个实例化过后的对象， 并且这个this指针需要由调用方提供给被调用方（因为被调用的函数并不知道何时会出现该类的实例化对象）  </p><p>所以如何传递this指针就成为一个问题， C++标准并未规定如何传递this， 所以不太编译器传递this的方式不同</p><p>msC++提供一个 <strong>thiscall</strong>约定，它讲this指针传递到ECX中， 并且由被调用函数清除栈中参数。  </p><p>GNU g++ 将this看成所有非静态成员函数的第一个隐含参数， 其它方面与cdecl相同 ， 因此， 对使用g++编译的代码来说， this永远是放在栈顶的， 并且由调用者删除栈中参数  </p><p>其它调用约定还有很多， 此处不再赘述。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验：RC4算法</title>
    <link href="/4Cc3.github.io/2024/02/18/%E5%AE%9E%E9%AA%8C%EF%BC%9ARC4%E7%AE%97%E6%B3%95/"/>
    <url>/4Cc3.github.io/2024/02/18/%E5%AE%9E%E9%AA%8C%EF%BC%9ARC4%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="RC4算法原理"><a href="#RC4算法原理" class="headerlink" title="RC4算法原理"></a>RC4算法原理</h2><p>RC4算法的加密部分就是单纯的将一个密钥流与明文逐字节的进行一次异或，其真正关键的地方在于如何生成密钥流  </p><p>在生成密钥流的时候用到了两个算法， 分别是key-scheduleing algorithm（KSA）算法和pseudo-random generation algorithm（PRGA），而这两个算法则是RC4的核心 , 接下来将以长度为256的明文为例子</p><hr><h2 id="KSA"><a href="#KSA" class="headerlink" title="KSA"></a>KSA</h2><p>ksa首先会初始化一个S盒， 初始化的过程非常的简单， 只需要将S盒按照1-256依次赋值即可  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">255</span>;i++)&#123;<br>S[i]=i;<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><p>然后，建立一个临时数组， 称为T盒，大小与S盒相同，用原始密钥对T进行循环填充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">255</span>;i++)&#123;<br>           T[i]=K[i % keylen];<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><p>此时，初始化工作已经完成，接下来将进行置换操作  ，对S盒中的元素的位置进行如下交换操作  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>&#123;<br>   j = (j + S[i] + T[i]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-built_in">swap</span>(S[i], S[j]);<br>&#125;<br>   <br></code></pre></td></tr></table></figure><hr><h2 id="PRGA"><a href="#PRGA" class="headerlink" title="PRGA"></a>PRGA</h2><p>建立S盒之后，S盒仍然是会发生变化的， 在PRGA中每生成一个字节的密钥流， 就会打乱一次S盒  ,具体步骤如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化i，j为0</span><br><span class="hljs-type">int</span> cnt=<span class="hljs-number">256</span>;<br><span class="hljs-type">int</span> key[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">while</span>(cnt--)<br>&#123;<br>    <span class="hljs-comment">//i自增1</span><br>    i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//j自增S[i]</span><br>    j = (j + S[i]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//交换，打乱S表</span><br>    <span class="hljs-built_in">swap</span>(S[i], S[j]);<br>    <span class="hljs-comment">//使用变量t保存输出S表的下标</span><br>    t = (S[i] + S[j]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//存储一字节的密钥流序列k</span><br>    key[i]=S[t];<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说,RC4还是一个相当简单的算法的, 其核心思想为生成密钥流,只要能找到对应生成密钥流的逻辑就能轻松的解出题目,<br>只要知道RC4中KSA盒PRGA算法的细节,再找到初始密钥k, 就能自己生成一个密钥流, 对密文进行解密</p><p>最后给出一份实验代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> char unsigned char <span class="hljs-comment">//这里记得使用无符号的char, 否则在置换密钥流的时候会出现段错误(访问负数下标)</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string dat=<span class="hljs-string">&quot;welcome to join the SUDA Security and the ATS-Team!!!&quot;</span>;<span class="hljs-comment">//length=53</span><br><span class="hljs-type">int</span> dataLen=<span class="hljs-number">53</span>;<br>string key=<span class="hljs-string">&quot;Sud@s3curi3ty&quot;</span>;<br><span class="hljs-type">int</span> keylength=<span class="hljs-number">13</span>;<br><span class="hljs-type">char</span> S[<span class="hljs-number">256</span>],T[<span class="hljs-number">256</span>];<br><span class="hljs-type">char</span> keyStream[<span class="hljs-number">256</span>];<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)&#123;<br>S[i]=i;<br>T[i]=key[i%keylength];<br>&#125;<br><br>j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)&#123;<br>j=(j+S[i]+T[i])% <span class="hljs-number">256</span>;<br><span class="hljs-built_in">swap</span>(S[i],S[j]);<br>&#125;<br><br>j=<span class="hljs-number">0</span>;<br>i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;dataLen;cnt++)&#123;<br><br>i=(i+<span class="hljs-number">1</span>)%<span class="hljs-number">256</span>;<br>j=(j+S[i])%<span class="hljs-number">256</span>;<br><br><span class="hljs-built_in">swap</span>(S[i],S[j]);<br>tmp=(S[i]+S[j])%<span class="hljs-number">256</span>;<br>keyStream[cnt]=S[tmp];<br><br><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;dataLen;i++)&#123;<br><span class="hljs-type">int</span> a=(<span class="hljs-type">int</span>)(dat[i]);<br><span class="hljs-type">int</span> b=(<span class="hljs-type">int</span>)(keyStream[i]);<br><br>cout&lt;&lt;(a^b)&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>加密算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于逆向中遇到的变量大小的问题</title>
    <link href="/4Cc3.github.io/2024/02/13/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <url>/4Cc3.github.io/2024/02/13/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>首先, 计算机中最基本的单位是bit, 一个bit只有0或者1两种状态  </p><p>而在做逆向的过程中最基本的单位是一个byte, 也就是两个十六进制数, 一个byte最大可以表示的整数为255(也就是FF)。 有些同学会发现， ASCII码表的长度刚好也是256， 其刚好是一个byte可表示的全部范围。</p><p>在x86架构中，偏移量一般都是用十六进制表示的，并且每一个数字对应的就是一个byte， 例如： [rsp+0h] 和 [rsp+4h]</p><p><img src="/4Cc3.github.io/images/pasted-11.png" alt="upload successful"></p><p> 这两个都是表示一个取值， 分别对应rsp+4h和rsp+0h位置的值。 而在观察后发现， 这两个变量存储的空间上刚好差了4h， 这里4h代表的就是4 byte， 也就是说， 这两个变量如果类型相同的话， 可以推断出两个变量的长度就为4 byte。 </p><p>而在之前的博文中提到过，x86架构下规定word的长度为2 byte是定死不变的， 所以这里4 byte刚好就是DWORD， 也就是一个整形的长度 ， 即为一个32 bit的数， 对应的就是8位十六进制数（其最大表示为FFFF FFFF） ，此处ida已经帮我们标注好了，该变量是一个无符号整形。</p><p>再通过观察可以发现这两个变量其实是相邻的，那么假如此时有一个调用为v4[1] , 那么这个语句就代表以v4的长度，取其相邻的下一个数。意思就是v4是一个DWORD， 那么v4[1]就是在v4的地址上再加4个byte ，（因为DWORD的长度是4byte），那么v4[1]代表的其实就是v5这个变量。  </p><p>在做逆向的过程中，有些时候还会遇到结构体的问题， 在修复结构体时也要灵活识别每个成员变量的长度， 推断其属于哪种类型，这里简单给出一些类型对应的长度:  </p><table><thead><tr><th>类型</th><th>二进制长度</th><th>十六进制长度</th><th>十六进制最大表示数</th></tr></thead><tbody><tr><td>char</td><td>8位</td><td>2位</td><td>FF</td></tr><tr><td>int、unsigned int、DWORD</td><td>32位</td><td>8位</td><td>FFFF FFFF</td></tr><tr><td>指针（32位程序）</td><td>32位</td><td>4位</td><td>FFFF FFFF</td></tr><tr><td>指针（64位程序）</td><td>64位</td><td>16位</td><td>FFFF FFFF FFFF FFFF</td></tr><tr><td>long long、 QWORD</td><td>64位</td><td>16位</td><td>FFFF FFFF FFFF FFFF</td></tr></tbody></table><p>这里给出的十六进制最大表示数的意义是如下：</p><p><img src="/4Cc3.github.io/images/pasted-15.png" alt="upload successful">  </p><p>方便大家用计算器测试， 因为只有用最大表示数才能直观的看出某一个长度的变量到底是多少位</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验: 从应用程序中加载和链接共享库</title>
    <link href="/4Cc3.github.io/2024/02/09/%E5%AE%9E%E9%AA%8C-%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
    <url>/4Cc3.github.io/2024/02/09/%E5%AE%9E%E9%AA%8C-%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><strong>本实验使用linux系统中自带的库函数实现在程序中加载共享库</strong></p><p>一般在程序中不会依赖这种方法实现共享库的加载, 更多的情况是在编译阶段通过引入头文件的方式, 直接将需要引入的符号直接在编译阶段引入, 而本实验实现通过一个文件路径和符号名称实现在任意一个程序中加载共享库  </p><p>本实验将会使用到的函数如下:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br>   <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flag)</span></span>;<br>   <span class="hljs-comment">// 若成功返回指向句柄的指针,否则返回NULL, filename为一个路径, flag为可选项, 一般使用RTLD_LAZY即可</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dlsym</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle , <span class="hljs-type">char</span> *symbol)</span></span>; <br>   <span class="hljs-comment">//若成功则返回指向符号的指针, 否则返回NULL, handle为已经打开的共享库的句柄, symbol为要使用的符号</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlclose</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle)</span></span>;<br>   <span class="hljs-comment">// 成功返回0 出错返回-1;</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">dlerror</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>   <span class="hljs-comment">//如果有调用失败的情况则返回出错信息,否则返回NULL  </span><br>   <br></code></pre></td></tr></table></figure><p>首先对以下程序进行编译</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-type">int</span> addcnt;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addvec</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y, <span class="hljs-type">int</span> *z,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        addcnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>                z[i]=x[i]+y[i];<br><br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>  使用如下指令编译共享库文件:  </p><pre><code class="hljs">  ❯ gcc -share -fpic addvec.c -o libvector.so  </code></pre><p>   -share选项将会使用动态库, -fpic参数是告诉编辑器产生于位置无关的代码(Position-Independent Code)  </p><p>   然后将libvector.so移动到同目录下名为lib的文件夹下, 此处是为了体现dlopen函数中的filename参数是文件路径</p><p>在mian.c中写如下代码  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><br><br>       <span class="hljs-type">void</span> *handle;<br>       <span class="hljs-built_in">void</span>(*addvec)(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>*,<span class="hljs-type">int</span> * ,<span class="hljs-type">int</span>  );<br>       <span class="hljs-type">char</span> *error;<br><br>       handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;./lib/libvector.so&quot;</span>,RTLD_LAZY);<br><br>       <span class="hljs-keyword">if</span>(!handle)&#123;<br>               <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">dlerror</span>());<br>               <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>       &#125;<br><br><br>       addvec = <span class="hljs-built_in">dlsym</span>(handle , <span class="hljs-string">&quot;addvec&quot;</span>);<br><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dlerror</span>()!=<span class="hljs-literal">NULL</span>)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;failed&quot;</span>);<br>               <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>       &#125;<br><br><br>       <span class="hljs-built_in">addvec</span>(x,y,z,<span class="hljs-number">2</span>);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z=[%d,%d]\n&quot;</span>,z[<span class="hljs-number">0</span>],z[<span class="hljs-number">1</span>]);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;execute successfully\n&quot;</span>);<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以编译main.c了</p><pre><code class="hljs">❯ gcc main.c   </code></pre><p> 此时在同名目录下就会生成一个a.out 是一个可执行文件, 可以正常运行了  </p><pre><code class="hljs"> ❯ ./a.outz=[4,6]execute successfully</code></pre>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是动态库</title>
    <link href="/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <url>/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>动态库的全称是_”动态链接共享库”_  , 其是一个目标模块, 在运行和加载时可以加载到任意的内存地址, 并和一个在内存中的程序链接起来, 这个过程叫做 <em>动态链接(dynamic linking)</em>  , 其是由一个叫做 <em>动态链接器(dynamic linker)</em> 的程序来执行的。</p><p>在linux中动态库通常被叫做共享目标（shared object） 用.so作为后缀, 而在windows中叫做动态链接库, 用.dll做后缀  </p><p>动态链接库的工作原理如下:  </p><p><img src="/4Cc3.github.io/images/pasted-9.png" alt="动态链接库工作流程">  </p><p><em>此处的图片出自《深入理解计算机系统》，main2.c在本文中命名为main.c, prog21在本文中命名为prog</em></p><p>首先, 先由翻译器将main.c中的代码(以及其引入的头文件) 编译成obj文件, 其次再由链接器将so文件和obj文件链接起来, 在执行时, 加载器会根据链接时指定的<br>地址来加载so文件中的代码段 ,这个过程由动态链接器完成, 下面给出实验过程  </p><p><em>注意: 此时使用的代码与上一章””什么是静态库”中展示的代码相同</em>  </p><p>使用如下命令生成libvector.so文件</p><pre><code class="hljs">❯ gcc -shared -fpic -o libvector.so addvec.c multvec.c</code></pre><p>-shared选项代表生成一个共享目标文件(也叫动态库) , -fpic代表生成与位置无关的代码  (编译共享库时总是需要开启此选项)</p><p>随后, 将动态库链接到主程序中  </p><pre><code class="hljs">❯ gcc -o prog main.c ./libvector.so</code></pre><p>然后就成功生成了名为prog的可执行文件</p><p>动态链接器(ld-linux.so)的工作原理如下:  </p><ul><li>重定位libc.so的文本和数据到某个内存段  </li><li>重定位libvector.so</li><li>重定位porg中所有对libc.so和libvector.so定义的符号的引用</li></ul><p>最后动态链接器再将控制传递给应用</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是静态库</title>
    <link href="/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>静态库(static library)是编译系统的一种机制, 用以解决如下问题:  </p><ul><li>编译器如何向用户提供一些标准函数</li></ul><p>一种方式是将标准函数全部放到一个目标文件(object file)中, 但是这么做就需要用户每次编译时采用  </p><pre><code class="hljs">linux&gt; gcc main.c /usr/lib/libc.o   </code></pre><p>这种方法对程序员有适当的便利, 但是缺点是每次编译时都需要把整个目标文件全部拷贝到可执行文件中去, 会增大文件的体积  </p><p>其次, 对于标准函数的改变将会需要重新编译整个源文件, 费时费力。  </p><p>所以，静态库的概念被提出来，以解决上述问题。   </p><p>在静态库中， 不同的函数被放在不同的模块中，在连接时，连接器只复制被引用的目标模块，这样就减少了程序的占用空间。  </p><p>下面给出构造静态库和使用静态库的实验  </p><p><img src="/4Cc3.github.io/images/pasted-6.png" alt="addvec.c"></p><p><img src="/4Cc3.github.io/images/pasted-7.png" alt="mulvec.c"></p><p>使用如下指令编译  </p><pre><code class="hljs">❯ gcc -c addvec.c multvec.c</code></pre><p>这里的-c指令是在链接阶段停止, 只做预处理, 编译 ,汇编, 这会将程序编译成一个obj文件,在同目录下生成同名的.o文件   </p><p>编译好之后运行  </p><pre><code class="hljs">linux&gt; ar rcs libvector.a addvec.o mulvec.o  </code></pre><p>就可以生成一个名为libvector.a的静态链接库文件(a的意思是archive)</p><p>为了调用生成的库文件, 编写如下源程序<br><img src="/4Cc3.github.io/images/pasted-8.png" alt="upload successful"></p><p>然后在编译可执行文件时, 使用如下指令  </p><pre><code class="hljs">linux&gt; gcc -c main.c</code></pre><p>这个指令先生成一个关于main的目标文件, 但是此时并不进行连接, 也就是说无法执行</p><p>然后再执行以下指令</p><pre><code class="hljs">linux&gt; gcc -static -o prog main.o ./libevector.a</code></pre><p>-static参数告诉编译器, 连接器应该构建一个完全链接的可执行文件, 它可以直接加载到内存并运行, 此选项会禁用动态库, 也就是说会把动态库中的所有东西都编译出来, 一般编译出来的东西都很大</p><pre><code class="hljs">p.s:在linux环境下, 链接库文件的后缀为.a, 在windows平台下后缀通常为.lib </code></pre><p>总得来说, 先将自己写好的代码(addvec.c和multvec.c)编译为obj文件, 然后通过ar工具将可重定位文件链接为一个.a文件(静态链接库文件)  </p><p>在这里还涉及到一个隐式函数的问题, 在c语言中, 如果一个函数在引用时没有声明, 那么在编辑器使用它的时候会自动为其添加隐式声明, 在链接时寻找其符号</p><p>紧接着, main.c源文件在通过翻译器(cpp,ccl,as)的作用下, 生成一个main.o(可重定位目标文件), 然后再与libvector.a(我们自己构建的静态链接库), libc.a(GNU提供的标准库文件)链接, 生成一个完全链接的可执行目标文件  </p><p>在此过程中, 链接器不会使用multvec.o中的内容 , 因为程序没有引用multvec.o中的符号  </p><p>在使用静态链接库时, 一般需要把他们放在命令行的结尾, 并且根据依赖关系进行排序, 否则就可能会发生”undefined reference”的错误, 这种错误的发生与编辑器实现链接时的规则有关, 但是近代的gcc有没有改善这一问题暂时还不清楚, 有可能以后不会再遇到这种问题也说不定，这块的内容还没有做过实验</p><p>对于上述问题的解决方法, 可以用ar工具将多个.a文件再次合并为一个单独的.a文件</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符号和符号表</title>
    <link href="/4Cc3.github.io/2024/02/07/%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
    <url>/4Cc3.github.io/2024/02/07/%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>首先先讲一个知识: 在c语言中的static的作用为使符号成为模块内部的私有符号, 类似于c++和java中的private, 加了static的变量或函数则不可在外部模块中被访问。<br>而在后续的描述中，统一把单个执行某一种功能的c语言源文件称为“模块”</p><p>在符号表中有以下三种变量：  </p><ul><li>全局连接器符号（由本模块定义的并且能被其他模块引用的全局符号）， 对应非静态函数和全局变量  </li><li>外部符号（由其他模块定义并被本模块应用的全局符号）</li><li>局部符号（只被本模块定义和应用的符号）</li></ul><p>在.symtab段中的符号表不包括本地非静态变量的任何符号(局部变量), 因为他们是被存放在栈中的。  </p><p>但是如果局部变量被加了static属性，那么该变量会在.data段和.bss段中被分配一个空间, 并且在.symtab段中有唯一名字的本地连接器符号</p><p>符号表的条目定义如下, 使用readelf即可读到一个目标文件中的符号表</p><p><img src="/4Cc3.github.io/images/pasted-5.png" alt="upload successful"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF文件格式简述</title>
    <link href="/4Cc3.github.io/2024/02/06/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/4Cc3.github.io/2024/02/06/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="计算机编译可执行文件时的步骤"><a href="#计算机编译可执行文件时的步骤" class="headerlink" title="计算机编译可执行文件时的步骤"></a>计算机编译可执行文件时的步骤</h3><p> 在计算机编译可执行文件时主要分为以下几个步骤:  </p><ol><li>对于一个或多个(在定义实现的情况下是多个源文件)c语言编写的ascii源文件,先由预处理器将头文件,宏定义等内容替换, 形成一个ascii码的中间文件: <strong>.i文件</strong>, 此时文本和编写的源代码差别不是很大  </li><li>编译器(ccl)将.i文件翻译成一个ascii的汇编语言文件: <strong>.s文件</strong> ,里面是可读的汇编指令</li><li>汇编器(as)将.s文件翻译成一个或多个可重定位目标文件<br>  <strong>(relocatable object file)</strong> : <strong>.o文件</strong> , 此时以及将ascii文件编译为hex文件, 其文件格式符合elf文件格式  </li><li>连接器(ld)将各个可重定位目标文件(后面简称obj文件)和一些必要的系统目录组合, 创建一个可执行目标文件 <strong>(executable object file )</strong></li></ol><p>此时, 一个程序就被编译好了, 在shell中直接输入文件名即可运行, shell在加载的过程中会使用一个名为loader的函数, 它将可执行文件中的代码数据复制到内存, 然后将控制权转移到函数的开头 </p><p>对于目标文件(object file) 有三种形式, 分别是</p><ul><li><strong>可重定位目标文件(relocatable object file )</strong>: 可以在编译时于其他obj文件合并</li><li><strong>可执行目标文件(executable object file)</strong>:  可直接被复制到内存并执行</li><li><strong>共享目标文件(shared  object file)</strong>:  lib或者dll等文件</li></ul><p>ELF的全称为(Executable and Linkable Format), 无论是那种可执行文件的格式, 其基本概念是相似的</p><hr><br><h3 id="ELF-可重定位目标文件的格式"><a href="#ELF-可重定位目标文件的格式" class="headerlink" title="ELF 可重定位目标文件的格式"></a>ELF 可重定位目标文件的格式</h3><p>ELF header以十六字节的序列开始，该序列描述了生成文件的word长度和字节顺序。<br>而其剩下的部分包含各类信息，其包括  </p><p><strong>ELF头的大小，目标文件的类型，（可执行，共享，可重定位），机器类型（x86-64）,section header table的文件偏移，section header table的条目数量和大小等</strong>   </p><p>不同节的位置和大小都是由section header table描述的，其中目标文件中每一个字节都有一个固定大小的entry。  </p><p><img src="/4Cc3.github.io/images/pasted-1.png" alt="upload successful">  </p><p>在section header table和elf文件头中间的就是节， 一般elf文件包含以下几个节  </p><table><thead><tr><th align="left">段   &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</th><th align="left">存储内容</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">已经编译的机器代码</td></tr><tr><td align="left">.rodate</td><td align="left">一些只读数据, 通常是字符串或者是一些常量</td></tr><tr><td align="left">.data</td><td align="left">已经初始化的全局变量和静态c变量,以及所有被初始化为0的全局变量或静态变量</td></tr><tr><td align="left">.bss</td><td align="left">未初始化的全局变量和静态变量,  这个节在obj文件中不占用实际的空间, 它仅仅是一个占位符</td></tr><tr><td align="left">.symtab</td><td align="left">一个符号表,它存放在程序中定义和引用的函数和全局变量的信息, 也就是符号表</td></tr><tr><td align="left">.rel.text</td><td align="left">.text节中的位置的列表</td></tr><tr><td align="left">.rel.data</td><td align="left">被模块引用或定义的所有全局变量的重定位信息</td></tr><tr><td align="left">.debug</td><td align="left">调试符号表, 只有以-g选项编译程序时才会得到这张表</td></tr><tr><td align="left">.line</td><td align="left">原始c程序中的行号和.text节中机器指令之间的映射, 只有以-g编译程序时才会得到这张表</td></tr><tr><td align="left">.strtab</td><td align="left">字符串表</td></tr></tbody></table><p>其中后五条见的都比较少, 尤其是在逆向工程中一般都是不含这些信息的  </p><pre><code class="hljs">p.s:.bss段的全称叫(Block Storage Start) 其用于表示未初始化的数据</code></pre><p>除此之外，有些时候还会见到.init_array和.init这样的节，其主要用在so文件中，用来对elf文件进行初始化,对于init_array的设置方法如下:</p><p>在GNU C中 可以在函数后面添加以下语句:  </p><pre><code class="hljs">__attribute__((constructor));__attribute__((destructor));  </code></pre><p> 这个语句可以用来给函数设置属性, 变量属性, 类型属性<br> 而其中的constructor和destructor为构造函数的属性, 这类函数将会在main函数之前被执行, 可见在加了该属性的函数在ida中则会在init_array段被调用</p><p><img src="/4Cc3.github.io/images/pasted-2.png" alt="upload successful"></p><p><img src="/4Cc3.github.io/images/pasted-3.png" alt="upload successful">  </p><p>在windows平台下，该语法仍然成立</p><p>在constructor中还可以携带参数， 例如  </p><pre><code class="hljs">__attribute__((constructor(100))) void load_init();__attributr__((constructor(102))) void load_file();</code></pre><p>里面的参数代表执行的优先级</p><p>通过这种方法可以实现smc、加壳等加密反调试手法，具体的实验则会在后面的文章中具体展示  </p><p>而关于_<em>attribute_</em> 的相关用法 可以参考<a href="https://www.jianshu.com/p/c8bea3807527">该博客</a>   </p><p>关于其具体的用法在后续的文章中也会给出具体的实验(如果有时间的话做一下, 因为感觉这里面大多数的东西不是很重要)</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/4Cc3.github.io/2024/02/04/hello-world/"/>
    <url>/4Cc3.github.io/2024/02/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>我会在这里记录我的学习过程</p><p><img src="/4Cc3.github.io/images/%E6%8D%A3%E8%9B%8B%E7%8C%AB.gif#pic_center" alt="无敌导弹猫"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>word到底是什么?</title>
    <link href="/4Cc3.github.io/2024/02/03/x86%E5%AD%A6%E4%B9%A0/"/>
    <url>/4Cc3.github.io/2024/02/03/x86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>一直搞不清楚word到底是什么单位，在ida中也经常会见到DWORD和QWORD这些类型，在我的印象里word一直是两个byte组成的，但是又经常看到说word是根据cpu位数决定的，所以在这里写一篇文章记录一下学习探讨的过程  </p><p>首先，word这个单位是描述计算机进行数据处理的时候一次存取，加工，传送的数据长度，一般与寄存器的长度相同  </p><p>在32位机中1word是32bit<br>在64位机中1word是64bit<br>在16位机中1word是16bit  </p><p>而intel厂商为了可移植性，统一规定了1word为16bit<br>这也是为什么无论32bit的程序还是64bit的程序在ida反编译的结果中都是1 word对应2 byte</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
