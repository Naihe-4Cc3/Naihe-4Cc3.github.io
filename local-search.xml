<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实验: AES算法</title>
    <link href="/4Cc3.github.io/2024/03/09/%E5%AE%9E%E9%AA%8C-AES%E7%AE%97%E6%B3%95/"/>
    <url>/4Cc3.github.io/2024/03/09/%E5%AE%9E%E9%AA%8C-AES%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h1><h2 id="AES算法流程"><a href="#AES算法流程" class="headerlink" title="AES算法流程"></a>AES算法流程</h2><p>首先, AES是需要对输入字节序列进行分组的, 一般是16个字节一组, 也就是128位, 所以本次实验主要以128位的AES为主  </p><p><img src="/4Cc3.github.io/images/image_1.png" alt="字节序列排列方式">  </p><p><img src="/4Cc3.github.io/images/image_2.png" alt="算法流程图,来源:https://zhuanlan.zhihu.com/p/78913397"></p><p>观察上图, 可以发现AES一般是十轮加密, 每一轮有四个操作, 分别是<em>字节代换, shift rows, mix column 密钥加层</em> 在密钥加层会需要用到一次密钥  </p><h2 id="密钥加层"><a href="#密钥加层" class="headerlink" title="密钥加层"></a>密钥加层</h2><p>密钥加层还是比较简单的, 其主要操作为将明文矩阵和子密钥矩阵一一对应的异或一下就好了  </p><p><img src="/4Cc3.github.io/images/pasted-39.png" alt="密钥加示意图">  </p><h2 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h2><p>字节代换主要是通过一个S_box来将字节进行一次映射, S_box有单独的生成算法, 在加密和解密时会使用不同的S_box  </p><p><img src="/4Cc3.github.io/images/pasted-40.png" alt="S_box示意图"></p><p>而代码中实现这个部分也很简单,比较常见的形式是<br><code>PlainArray[i] = S_box[PlainArray[i] &gt;&gt; 4][PlainArray[i] &amp; 0x0F];</code></p><p>上面的代码中, plainArray是一个字节数组, 每一个元素都是8bit, 而字节代换层要求, 对于一个byte元素来说, 其高四位作为映射时的行号,低四位作为列号, 而四位bit刚好可以表示0-15 16个数字, 对应S_box 16*16共256个元素  </p><p><img src="/4Cc3.github.io/images/pasted-41.png" alt="字节代换示意图"></p><h2 id="shiftRows"><a href="#shiftRows" class="headerlink" title="shiftRows"></a>shiftRows</h2><p>行位移就是将举证进行循环位移, 第一行不移动, 第二行向左移动1个位置, 第三行向左移动2个位置, 第三行向左移动3个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//加密时运行的shiftRows代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ShiftRows</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *PlainArray)</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-comment">//传入的PlainArray是一个从char类型的二维数组,其原型为char PlainArray[4][4] , 将其转换为int*类型时, 每次取值会取连续的4个字节, 也就是AES矩阵中的一行  </span><br>  <br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//第一行 不移位</span><br>  <span class="hljs-comment">//PlainArray[0] = PlainArray[0];</span><br><br>  <span class="hljs-comment">//第二行 左移8Bit</span><br>  PlainArray[<span class="hljs-number">1</span>] = (PlainArray[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">8</span>) | (PlainArray[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">24</span>);<br><br>  <span class="hljs-comment">//第三行 左移16Bit</span><br>  PlainArray[<span class="hljs-number">2</span>] = (PlainArray[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">16</span>) | (PlainArray[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>);<br><br>  <span class="hljs-comment">//第四行 左移24Bit</span><br>  PlainArray[<span class="hljs-number">3</span>] = (PlainArray[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">24</span>) | (PlainArray[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/4Cc3.github.io/images/pasted-42.png" alt="shiftRows图解"></p><p>而其对应的解密操作即为向相反的方向进行位移, 原来向左位移, 则解密时向右位移即可  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//解密时运行的shiftRows代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ReShiftRows</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *CipherArray)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//第一行 不移位</span><br>  <span class="hljs-comment">//CipherArray[0] = CipherArray[0];</span><br><br>  <span class="hljs-comment">//第二行 右移8Bit</span><br>  CipherArray[<span class="hljs-number">1</span>] = (CipherArray[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) | (CipherArray[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">24</span>);<br><br>  <span class="hljs-comment">//第三行 右移16Bit</span><br>  CipherArray[<span class="hljs-number">2</span>] = (CipherArray[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) | (CipherArray[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">16</span>);<br><br>  <span class="hljs-comment">//第四行 右移24Bit</span><br>  CipherArray[<span class="hljs-number">3</span>] = (CipherArray[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) | (CipherArray[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">8</span>);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而这里的左移和右移是反直觉的, 这个具体原因涉及到端序的问题, 不清楚的读者可以运行以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//运行以下代码, 观察输出情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> p[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><br><br>cout&lt;&lt;*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>]))&lt;&lt;endl;<br><br>cout&lt;&lt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&gt;&gt;<span class="hljs-number">8</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;((*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&gt;&gt;<span class="hljs-number">8</span>))&lt;&lt;endl;<br><br>cout&lt;&lt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-number">8</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;((*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-number">8</span>))&lt;&lt;endl;<br><br><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br> <br> cout&lt;&lt;(<span class="hljs-type">int</span>)p[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br> &#125;<br> cout&lt;&lt;endl;<br> &#125;<br> <br> <br>&#125;<br><br></code></pre></td></tr></table></figure><p>在x86架构下, 存储数据时, 是低字节存低位数, 高字节存高位数。例如<br><code>&#123;00,01,02,03&#125;</code>这个数据, 在计算机中按双字存时会显示为  <code>dd 3020100</code>, 因此, 对一个双字元素进行位移操作时, 要考虑端序的问题。  </p><h2 id="mixColumn"><a href="#mixColumn" class="headerlink" title="mixColumn"></a>mixColumn</h2><p>列混淆可以简单理解为, 将输入矩阵与一个混淆矩阵进行乘操作, 在加密时就乘加密矩阵, 解密时乘解密矩阵, 这里的加密矩阵和解密矩阵相乘会得到一个单位矩阵(单位矩阵就跟代数中的数字1是一样的)  </p><p><img src="/4Cc3.github.io/images/pasted-43.png" alt="加密矩阵与解密矩阵相乘"></p><p><img src="/4Cc3.github.io/images/pasted-44.png" alt="加密时进行的操作"></p><p><img src="/4Cc3.github.io/images/pasted-45.png" alt="解密时进行的操作"></p><p>这里的正矩阵和逆矩阵中的数字是标准AES提供的,一般也可以作为特征识别</p><p>只不过这里的乘操作稍微有些复杂, 并不是传统的矩阵乘法, 而是域上的乘法, 关于伽罗瓦域乘法的具体内容这里不展开讲, 因为过于复杂, 我们只需要了解如何进行伽罗瓦域上的乘法即可</p><p>首先, 使用输入矩阵乘加密矩阵相乘 </p><p><img src="/4Cc3.github.io/images/pasted-47.png" alt="求状态矩阵"></p><p>然后得到的状态矩阵可以用下图表示 </p><p><img src="/4Cc3.github.io/images/pasted-46.png" alt="状态矩阵表示"><br>这里用来连接每一项之间的运算符为伽罗瓦域乘法操作</p><p>这个矩阵中对应的行列其实和标准矩阵乘法的规则是一样的, 都是  </p><p>元素x在矩阵A所在的行中的每一个数字<br>乘<br>元素x在矩阵B所在的列中的每一个数字  </p><p>在伽罗瓦域上的加法是异或,乘法则是按照以下规则进行的  </p><p><img src="/4Cc3.github.io/images/pasted-48.png" alt="伽罗瓦域上的乘法">  </p><p>上面这个表达式的意思是, 对于一个8bit的二进制数来说, 如果它的最高位(也就是a7)为0, 那么就直接给他向左移一位就行了, 如果它的最高位是1, 那么就要把它和00011011进行一个异或(这里的00011011也是标准AES提供的, 其具体数值与加密矩阵和解密矩阵有关)  </p><p>而上图中给出的例子是进行了与0x02的乘法, 而这个与0x02的乘法也是最重要的, 因为所有的8bit数都可以拆成和若干个0x02和num相乘的异或式,</p><p>以00001101为例</p><p><img src="/4Cc3.github.io/images/pasted-49.png" alt="手写推导"></p><p>在上面的推导过程中,记num’为num这个数和2进行了一次伽罗瓦域乘,我们将其称为变换. </p><p>那么最终的结果就是进行了3次变化的num和进行了2次变化的num和没有进行变换的num相异或的形式.  </p><p>那么观察上面的推导式, 我们其实可以总结出一个规律, 我们将输入的byte记为num, 将进行运算的状态矩阵输入的byte记为mat, 那么对mat这个8bit数中的每一位进行从右到左的检测, 如果该位是0, 那么就说明需要对进行一次变化, 如果最低位是1, 那么就要将当前状态的num计入最终结果的异或式, 那么这么看来, 伽罗瓦域中的乘法就很好实现了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">GaloisMul</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mat, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ans = <span class="hljs-number">0</span>; <span class="hljs-comment">//最终组成的异或式的结果</span><br><span class="hljs-keyword">while</span> (mat)<br>&#123;<br><span class="hljs-comment">//如果当前mat的位数是1,那么就将当前状态的num计入最终的异或式</span><br><span class="hljs-keyword">if</span> (mat &amp; <span class="hljs-number">0x01</span>)<br>&#123;<br>ans ^= num;<br>&#125;<br><span class="hljs-comment">//Num_L右移一位，检测mat的下一位</span><br>mat &gt;&gt;= <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//如果当前mat的位数不是1, 那么就说明可以拆一个0x02出来, 那么就可以对式子进行化简, 将num*0x02进行合并, 也就是我们说的进行一次变换</span><br><span class="hljs-keyword">if</span> (num &amp; <span class="hljs-number">0x80</span>)<span class="hljs-comment">//如果num最高位为1</span><br>&#123;<br>num &lt;&lt;= <span class="hljs-number">1</span>;<br>num ^= <span class="hljs-number">0x1B</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>num &lt;&lt;= <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>将伽罗瓦域上的乘法搞定后, 就可以进行运算了, 前面也讲过, 在mixColumn的过程中, 会有两个矩阵, 分别是输入矩阵和给定的状态矩阵, 我们要将这两个矩阵进行域上的乘法来将他们合并, 所以最终的mixColumn的过程为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MixArray[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>] =<br>&#123;<br><span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>,<br><span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>,<br><span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>,<br><span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MixColum</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>(*PlainArray)[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//定义变量</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ArrayTemp[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">//初始化变量</span><br><span class="hljs-built_in">memcpy</span>(ArrayTemp, PlainArray, <span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//矩阵乘法 4*4</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br>PlainArray[i][j] =<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">0</span>], ArrayTemp[<span class="hljs-number">0</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">1</span>], ArrayTemp[<span class="hljs-number">1</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">2</span>], ArrayTemp[<span class="hljs-number">2</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">3</span>], ArrayTemp[<span class="hljs-number">3</span>][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>AES中的密钥是和加密单位矩阵同等规模的矩阵, 加密时输入的矩阵为4*4, 以byte为单位的矩阵, 那么AES最初的密钥也是这个规模  </p><p>当我们观察AES流程图时可以发现, 我们总共会进行十一轮密钥加, 并且每轮密钥加用的密钥都不一样, 但是我们最开始只用了一个16字节的密钥, 那么我们怎么才能搞到那么多的密钥呢, 这时就需要密钥生成算法来为后面几轮的密钥加提供密钥, 密钥生成的流程如下  </p><p>我们可以看到, 这里的密钥都是以列为单位的, 一列4个byte构成一个w, 4个w构成一个子密钥</p><p><img src="/4Cc3.github.io/images/pasted-50.png" alt="密钥生成流程图"></p><p>单另拿其中的一部分来看, 进行密钥生成的过程是这样的  </p><p><img src="/4Cc3.github.io/images/pasted-51.png" alt="密钥生成具体过程"></p><p>这里的g函数是将四个byte进行向左循环位移, 然后再逐字节进行S_box代换, 代换结束之后需要一个Rcon数组与新密钥的第一个byte进行一次异或</p><p>进行一轮生成后, 可以看到就生成了w4 w5 w6 w7这四组32位的串, 将他们连起来之后就是一个128位的新的密钥</p><h2 id="AES解密流程"><a href="#AES解密流程" class="headerlink" title="AES解密流程"></a>AES解密流程</h2><p><img src="/4Cc3.github.io/images/pasted-52.png" alt="解密流程图"></p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDA交叉引用</title>
    <link href="/4Cc3.github.io/2024/03/04/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/"/>
    <url>/4Cc3.github.io/2024/03/04/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="代码交叉引用"><a href="#代码交叉引用" class="headerlink" title="代码交叉引用"></a>代码交叉引用</h2><p>在IDA中, 指令转交控制权的方式叫做流, 在IDA中有三种流, 分别是普通流, 跳转流, 和调用流 </p><ol><li><p>普通流<br> 即为顺序执行,指令按照顺序执行就叫普通流  </p></li><li><p>调用流<br> 即为call这样的指令会被分配到一个调用流, 表示将控制权移交给目标函数, 一般情况下call指令也会被分配到一个普通流(在返回时会继续执行后面的指令)  </p></li><li><p>跳转流<br> 类似jmp jz jnz这样的指令会被分配到跳转流, 条件分支还会被分配一个普通流, 以在不进入分支的情况下继续执行代码.</p></li></ol><h2 id="数据交叉引用"><a href="#数据交叉引用" class="headerlink" title="数据交叉引用"></a>数据交叉引用</h2><p>在ida反汇编页面中, 数据的标题行显示的交叉引用的数量是有限制的, 可以在Options -&gt; General -&gt; Cross-reference -&gt; NUmber of displayed xrefs这个地方进行修改  </p><p>数据交叉引用分为三种  </p><ol><li><p>读取交叉引用<br> 在数据段中, ida会以<code>r</code>为结尾的后缀标注出数据引用 <img src="/4Cc3.github.io/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/image.png" alt="数据段反汇编"><br>在上图中, DATA XREF后面的标识的最后一位, 即为表示该数据交叉引用是什么类型的, main+E↑r这个引用就代表该引用是一个读取交叉引用</p></li><li><p>写入交叉引用, 后缀通常用w表示, 其代表有代码对改数据进行了写入操作  </p></li><li><p>偏移量交叉引用<br>其表示代码引用的是某个位置的地址(而非内容),其后缀为o, 例如全局数组的第一个地址, 或者是一个指针变量等. 偏移量交叉引用不一定是来自指令位置或数据位置, 其有可能来自程序数据部分.<br>例如C++中的虚函数, 如果一个函数是虚函数, 那么其标题行就会显示该函数与虚表的偏移量交叉引用. 并且构造函一般也会使用虚表的地址(如果有虚函数的话), 是可以通过虚表中的偏移量交叉引用找到构造函数的, 在c++中, 虚函数不会被直接引用, 肯定会通过虚表引用的</p></li></ol><h2 id="交叉引用列表"><a href="#交叉引用列表" class="headerlink" title="交叉引用列表"></a>交叉引用列表</h2><p>在subviews窗口中可以打开cross-references窗口, 就能看到完整的交叉引用列表了,当然也可以用快捷键<code>X</code>打开交叉引用窗口  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/4Cc3.github.io/2024/02/25/c-%E5%9F%BA%E7%A1%80/"/>
    <url>/4Cc3.github.io/2024/02/25/c-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>自从学了c++之后我才发现原来我根本就不会c++, 因此在这里记录一些c++基础知识。  </p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-友元"><a href="#1-友元" class="headerlink" title="1. 友元"></a>1. 友元</h3><p>  友元函数可以访问类中的private和protect成员，声明友元函数只需要在类中添加<code>friend</code>关键字与待声明函数的原型, 例如现有如下函数原型:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br>```  <br>该函数是一个输出流运算符重载函数, 我们将他定义在类的外部, 但是这么做就会面临一个问题, 那就是无法输出类中的私有变量, 此时我们就需要对其添加友元属性:  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><br>  上述代码会在类中将重载函数定义为友元函数, 此时该函数就相当于Complex类中定义的函数了。</p><h3 id="2-构造函数与拷贝构造函数"><a href="#2-构造函数与拷贝构造函数" class="headerlink" title="2. 构造函数与拷贝构造函数"></a>2. 构造函数与拷贝构造函数</h3><p>构造函数的形式是  </p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">classname</span>&#123;<br><br>  <span class="hljs-title function_">classname</span>(<span class="hljs-params">typename</span> <span class="hljs-params">var</span>)&#123;<br>    <span class="hljs-comment">//code</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个东西是干啥的呢, 比如你有一个代码为<code>classname a=3.14</code>, 那么编译器就会报错, 因为它不知道怎么把一个浮点数赋值给classname, 所以这个时候就需要你在类中定义这么一个构造函数, 来指定赋值时发生的行为。需要注意的是，在声明了一个构造函数后，你的所有<code>=</code>运算符也自动被重载了， 即你想写<code>a=3.14;</code>时，不用额外再写个<code>classname operator=(typename var)&#123;&#125;</code>这么个东西了。</p><p>并且，所有的类在声明时会自动带一个构造函数，这个自带的构造函数是用来处理同类型变量的，假如你有一个classname类型的对象QAQ，那么你想在声明阶段声明一个classname类型的AWA，并且想把这个QAQ的初始值设置为和AWA一样，那么直接写<code>classname AWA=QAQ;</code>即可，不需要重新再写一个构造函数(赋值时也是一样的)，但是假如你想让这个过程发生一些额外的行为，例如你想让AWA等于两倍的QAQ再减一，你就需要对构造函数进行一下重构，编译器自动生成的构造函数只能单纯的进行一次拷贝。</p><p>如果一个构造函数没有参数, 那么在对象创建时会自动调用, 如果有参数, 那么就需要用<code>classname var(par);</code>这种语句。</p><p>在栈上创建对象时，实参位于对象名后面，例如<code>Student stu(&quot;小明&quot;, 15, 92.5f)；</code>在堆上创建对象时，实参位于类名后面，例如<code>new Student(&quot;李华&quot;, 16, 96);</code>。</p><p>构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处。</p><p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。  </p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//声明运算符重载</span><br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><br><br><span class="hljs-built_in">complex</span>(<span class="hljs-type">int</span> a)&#123;<br>m_real=<span class="hljs-number">0.0</span>,<br>m_imag=<span class="hljs-number">0.0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  complex a;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么此时编译器就会报错（因为类中包含了构造函数，而创建对象时却没有调用。），但是把构造函数删掉，编译器就会使用默认的构造函数，反而不会报错了。或者也可以自己手动再添加没有参数的构造函数：<code>complex()&#123;&#125;;</code></p><p>如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。</p><p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</p><p>最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。<code>complex a;</code>和<code>complex a();</code>是一样的。</p><p>拷贝构造函数的形式是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">T</span> (<span class="hljs-type">const</span> T&amp; other_obj)&#123;&#125;<br></code></pre></td></tr></table></figure><p>拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。构造函数的形参必须是引用，但不限制为const，但普遍来说会加上const限制。</p><p>为什么必须是当前类的引用呢？<br>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>为什么是 const 引用呢？<br>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p><p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p>拷贝构造函数会在以下三种情况中被调用:  </p><ol><li>用类的一个对象去初始化类的另一个对象时  </li><li>如果函数的形参是类的对象, 调用函数时, 进行形参和实参结合(实参是caller传入的东西, 形参是放在寄存器或栈上的, callee分配的东西)</li><li>如果函数的返回值是类的对象, 函数执行完成返回时(返回时, callee会将要返回的对象拷贝给一个临时变量, 然后销毁callee中的对象, 回到caller的位置再将对象当做返回值返回)</li></ol><h3 id="3-初始化列表"><a href="#3-初始化列表" class="headerlink" title="3. 初始化列表"></a>3. 初始化列表</h3><p>  在写构造函数时, 不仅可以将成员变量在构造函数的函数体中赋值, 也可以将成员变量用初始化列表赋值, 初始化列表的书写方法如下:  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><span class="hljs-built_in">complex</span>()&#123;<br>  m_real=<span class="hljs-number">0.0</span>,<br>  m_imag=<span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  上述代码中, 两个构造函数的功能类似, 但是采取了两个不同的写法, 第一个构造函数在函数声明和函数体之间多了一个冒号和一个用逗号连接的列表, 具体用法是<code>变量名(表达式)[,变量名(表达式)...]</code><br>  该语句等价于 <code>变量名=表达式</code></p><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>C++中的引用(reference)使用符号”&amp;”表示, 这个东西看着和C中的取地址符是同一个符号, 但是这两个的作用却不相同, 在C++中引用相当于是一个变量的别名, 使用引用定义的变量和其原变量没有任何区别。  </p><p>例如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> la;<br><span class="hljs-type">int</span> &amp;a = la;<br></code></pre></td></tr></table></figure><p>使用该定义, 则变量a就是la, 操作a和操作la是一样的, c++在编译时会自动进行优化, 对a的所有操作都会变成直接对la的操作。</p><p>引用的应用有以下几点：</p><h3 id="1-做为函数参数"><a href="#1-做为函数参数" class="headerlink" title="1. 做为函数参数"></a>1. 做为函数参数</h3><p>在当做参数时，应用的参数可以直接操作传入的数字，而不是操作传入参数的拷贝<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>a+=<span class="hljs-number">0xcafe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_pointer</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span></span>&#123;<br>*a+=<span class="hljs-number">0xfe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_ref</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;<br>  a+=<span class="hljs-number">0xca</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">hello</span>(a);<br>  <span class="hljs-built_in">hello_pointer</span>(&amp;a);<br>  <span class="hljs-built_in">hello_ref</span>(a);<br>&#125;    <br><br></code></pre></td></tr></table></figure></p><p>上面的三个函数的反编译结果分别是</p>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; void __fastcall hello()</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               <span class="hljs-meta">public</span> _Z5helloi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               _Z5helloi proc <span class="hljs-built_in">near</span>                     <span class="hljs-comment">; CODE XREF: main+19↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               arg_0= <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001531</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001534</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                      <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001537</span> <span class="hljs-number">81</span> <span class="hljs-number">45</span> <span class="hljs-number">10</span> FE CA <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">add</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-number">0CAFEh</span><br><span class="hljs-symbol">.text:</span>000000014000153E <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000153F <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span>                               _Z5helloi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br></code></pre></td></tr></table></figure><p>hello 这个函数中, ecx中存放参数, 可见函数中新建了一个变量arg_0用来存放参数, 说明函数调用的参数是一个拷贝<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; int *__fastcall hello_pointer(int *)</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               <span class="hljs-meta">public</span> _Z13hello_pointerPi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               _Z13hello_pointerPi proc <span class="hljs-built_in">near</span>           <span class="hljs-comment">; CODE XREF: main+25↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001542</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001545</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001549</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000154D</span> 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000154F <span class="hljs-number">8D</span> <span class="hljs-number">90</span> FE <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0FEh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001555</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001559</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span>000000014000155B <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000155C <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span>                               _Z13hello_pointerPi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br></code></pre></td></tr></table></figure></p><p>  hello_pointer函数中, rcx是调用变量的地址, 而寻址后改变的是传入的原变量,能够起到改变传入的变量的效果  </p>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">          <span class="hljs-keyword">int</span> *__fastcall hello_ref(<span class="hljs-keyword">int</span> *)<br><span class="hljs-symbol">.text:</span>000000014000155E                               <span class="hljs-meta">public</span> _Z9hello_refRi<br><span class="hljs-symbol">.text:</span>000000014000155E                               _Z9hello_refRi proc <span class="hljs-built_in">near</span>                <span class="hljs-comment">; CODE XREF: main+31↓p</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; DATA XREF: .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; .pdata:0000000140005084↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000155F <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001562</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001566</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span>000000014000156A 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000156C <span class="hljs-number">8D</span> <span class="hljs-number">90</span> CA <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0CAh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001572</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001576</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001578</span> <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001579</span> <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000157A C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span>000000014000157A<br><span class="hljs-symbol">.text:</span>000000014000157A                               _Z9hello_refRi endp<br><br></code></pre></td></tr></table></figure><p>  而hello_ref函数传参是一个引用, 观察代码, 可以发现, 使用引用和使用指针传参是同样的效果,代码完全相同, 这就说明引用其实是编辑器代替你操作指针, 只不过使用引用将会减少代码量并提高代码可读性。  </p><p>指针与引用的区别：</p><ul><li>指针是可以独立存在的; 但是引用不行</li><li>引用必须要进行初始化，指针没有必要</li><li>指针可以设置为NULL， 但是引用不行</li><li>引用一旦进行初始化之后，不会再改变其指向；但指针可以</li></ul><h3 id="2-引用作为函数的返回值"><a href="#2-引用作为函数的返回值" class="headerlink" title="2. 引用作为函数的返回值"></a>2. 引用作为函数的返回值</h3><p>  语法：类型 &amp;函数名（形参列表）{ 函数体 }<br>  1.引用作为函数的返回值时，必须在定义函数时在函数名前加&amp;<br>  2.用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本</p><p>  例如:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">10</span>;<span class="hljs-comment">// 若func的返回值是一个生命周期大于func的变量时</span><br><span class="hljs-type">int</span> &amp;a = <span class="hljs-built_in">func</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="1-重载一般运算符"><a href="#1-重载一般运算符" class="headerlink" title="1. 重载一般运算符"></a>1. 重载一般运算符</h3><p>  这里的一般运算符指普通的二元运算符, 例如加减乘除<br>  以下列程序为例:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br>  <span class="hljs-built_in">complex</span>()&#123;<br>    m_real=<span class="hljs-number">0.0</span>,<br>    m_imag=<span class="hljs-number">0.0</span>;<br>  &#125;<br><br><br>  complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A) <span class="hljs-type">const</span>&#123;<br>    complex B;<br>    B.m_real = <span class="hljs-keyword">this</span>-&gt;m_real + A.m_real;<br>    B.m_imag = <span class="hljs-keyword">this</span>-&gt;m_imag + A.m_imag;<br>    <span class="hljs-keyword">return</span> B;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">complex::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  cout&lt;&lt;m_real&lt;&lt;<span class="hljs-string">&quot; + &quot;</span>&lt;&lt;m_imag&lt;&lt;<span class="hljs-string">&quot;i&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">4.3</span>, <span class="hljs-number">5.8</span>)</span></span>;<br>  <span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2.4</span>, <span class="hljs-number">3.7</span>)</span></span>;<br>  complex c3;<br>  c3 = c1 + c2;<br>  c3.<span class="hljs-built_in">display</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  仔细观察上面的程序, 我们在 complex 类中重载了运算符+，该重载只对 complex 对象有效, 当执行c3 &#x3D; c1 + c2;语句时，编译器检测到+号左边（+号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数operator+()，也就是转换为下面的形式：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3 = c1.<span class="hljs-keyword">operator</span>+(c2);<br></code></pre></td></tr></table></figure><br>  c1 是要调用函数的对象，c2 是函数的实参。<br>  当然, 上述写法是重载了一个成员函数, 对于运算符的重载也可以变为全局重载:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A, <span class="hljs-type">const</span> complex &amp;B)&#123;<br>  complex C;<br>  C.m_real = A.m_real + B.m_real;<br>  C.m_imag = A.m_imag + B.m_imag;<br>  <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><br>  当编译器检测到调用时,例如 <strong>c3&#x3D;c1+c2</strong> 加号两边都是complex类型的变量, 那么编译器就会使用如下的调用<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3=<span class="hljs-keyword">operator</span>+(c1,c2);<br></code></pre></td></tr></table></figure><br>  <font size=5>将运算符重载函数作为类的成员函数时，二元运算符的参数只有<strong>一个</strong>，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的,默认就是this。</font>  </p><h3 id="2-输入输出流运算符重载"><a href="#2-输入输出流运算符重载" class="headerlink" title="2. 输入输出流运算符重载"></a>2. 输入输出流运算符重载</h3><p>  一般来说, 这类运算符都是在类外部借用友元函数重载的, 具体原因是因为如果在类内部重载, 那么就需要先将对象实例化, 再通过对象来调用运算符, 例如<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Distance</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> feet;             <span class="hljs-comment">// 0 到无穷</span><br>        <span class="hljs-type">int</span> inches;           <span class="hljs-comment">// 0 到 12</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 所需的构造函数</span><br>        <span class="hljs-built_in">Distance</span>()&#123;<br>            feet = <span class="hljs-number">0</span>;<br>            inches = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">Distance</span>(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> i)&#123;<br>            feet = f;<br>            inches = i;<br>        &#125;<br>        ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp; os)<br>        &#123;<br>            os&lt;&lt;<span class="hljs-string">&quot;英寸：&quot;</span>&lt;&lt;feet&lt;&lt;<span class="hljs-string">&quot;\n英尺：&quot;</span>&lt;&lt;inches;<br>            <span class="hljs-keyword">return</span> os;<br>        &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Distance <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>)</span></span>;<br>    d1&lt;&lt;cout;<span class="hljs-comment">//相当于d1.operator&lt;&lt;(cout)</span><br>&#125;<br>```  <br>这里的就是通过成员函数进行声明, 在使用时, 运算符左值必须为对象。     <br>若不使用成员函数进行重载， 那么就该使用<span class="hljs-keyword">friend</span>关键字先在类中声明函数为友元函数  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out , complex a);<br>  ...<br><br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  而返回一个ostream的对象的原因是方便其可以在返回后继续进行输出or输入, 函数的定义也可以看到返回的是一个ostream类型的引用。而这个第一个参数其实是cout这个对象，而cout是在std中定义的对象。  </p><h3 id="3-重载-运算符"><a href="#3-重载-运算符" class="headerlink" title="3. 重载[]运算符"></a>3. 重载[]运算符</h3><p>  C++ 规定，下标运算符[ ]必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：<code>返回值类型 &amp; operator[ ] (参数);</code></p><p>  或者：<code>const 返回值类型 &amp; operator[ ] (参数) const; </code></p><p>  使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。</p><h3 id="4-重载-运算符"><a href="#4-重载-运算符" class="headerlink" title="4. 重载++ --运算符"></a>4. 重载++ --运算符</h3><p>  这两个都是一元运算符，重载方式如下：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>++()&#123;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<span class="hljs-comment">//++i</span><br><br>complex <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n)&#123;<br>  complex s = *<span class="hljs-keyword">this</span>;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<span class="hljs-comment">//i++</span><br></code></pre></td></tr></table></figure><br>  可以看到, 返回值是表达式的结果(基本上所有运算符重载的返回值都是表达式的结果)  </p><p>  而前自增和后自增的区别为是否传参, 后自增的参数<code>int n</code>没有任何意义</p><h3 id="5-C-重载-（强制类型转换运算符）"><a href="#5-C-重载-（强制类型转换运算符）" class="headerlink" title="5. C++重载()（强制类型转换运算符）"></a>5. C++重载()（强制类型转换运算符）</h3><p>在 C++ 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。</p><p>  类型强制转换运算符是单目运算符，也可以被重载，但只能<em>重载为成员函数</em>，<em>不能重载为全局函数</em>。经过适当重载后，<code>(类型名)对象</code>这个对对象进行强制类型转换的表达式就等价于<code>对象.operator 类型名()</code>，即变成对运算符函数的调用。</p><p>  对类型转化定义过的函数，编译器会在需要时自动调用，例如  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>...<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> real; &#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这个函数就对double()这个强制转换进行了定义, 需要注意的是, <em>对double运算符重载不需要指定返回类型</em>, 因为返回类型就是重载运算符本身代表的类型, 即为double</p><p>  定义之后, 在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Complex <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>)</span></span>;<br>cout &lt;&lt; (<span class="hljs-type">double</span>)c &lt;&lt; endl;  <span class="hljs-comment">//输出 1.2</span><br><span class="hljs-type">double</span> n = <span class="hljs-number">2</span> + c;  <span class="hljs-comment">//等价于 double n = 2 + c. operator double()</span><br>cout &lt;&lt; n;  <span class="hljs-comment">//输出 3.2</span><br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-C-const相关"><a href="#1-C-const相关" class="headerlink" title="1. C++ const相关"></a>1. C++ const相关</h3><ul><li><p>const成员变量  </p><p>const成员变量非常好定义, 只需要在定义时在最前面加上const关键字即可, 定义为const的变量无法更改其值  </p></li><li><p>const成员函数  </p><p>常成员函数的定义方法为在函数的最后加一个const关键字, 例如:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Student::getage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">return</span> m_age;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码中, getage函数加了const关键字, 那么其对所有成员变量的访问权限就变为了只读<br>需要注意的是, 加了const的和不加const的函数是两个完全不同的函数原型。<br>还有需要注意的事是，如果const关键字被加在了一个函数的最开头， 那么就说明该函数的返回值是一个常量， 不允许修改其返回值  </p></li><li><p>常对象<br>  定义常对象的语法和定义常量的语法类似：          </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-type">const</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br></code></pre></td></tr></table></figure><p> class为类名，object为对象名，params为实参列表， p为指针名。两种方式定义出来的对象都是常对象。 </p><p> 一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</p></li></ul><h2 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2. static关键字"></a>2. static关键字</h2><p>  声明为static的变量会存储在bss段或者data段，而不是在栈中，因此当一个函数的执行周期结束后并不会被释放掉，同时static不会破坏类的封装性，类外不能访问protect和private的变量。</p>]]></content>
    
    
    <categories>
      
      <category>C++编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++逆向工程</title>
    <link href="/4Cc3.github.io/2024/02/24/C-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/4Cc3.github.io/2024/02/24/C-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="C-逆向工程基础"><a href="#C-逆向工程基础" class="headerlink" title="C++逆向工程基础"></a>C++逆向工程基础</h2><p>在之前的文章中讲过了调用约定相关的知识, 这里就不在赘述, 阅读之前需要重点回顾一下thiscall和cdecl这两个调用约定  </p><h3 id="1-this指针"><a href="#1-this指针" class="headerlink" title="1. this指针"></a>1. this指针</h3><p>所有静态(public的)的c++成员函数都使用this指针, this都被初始化, 指向用于调用成员函数的对象, 例如  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">obj1.<span class="hljs-built_in">func</span>()<br>obj2.<span class="hljs-built_in">func</span>()<br>p_obj-&gt;<span class="hljs-built_in">func</span>()<br></code></pre></td></tr></table></figure><p>上面的三次调用func的过程中, this分别指&amp;obj1, &amp;obj2,  &amp;p_obj  , 微软的thiscall调用约定会将this传递到ECX寄存器中, 而GNU g++的编译器的cdecl调用约定会把this当作成员函数的第一个参数, 一般是最后一个压入栈中的。<br>以菜鸟教程中关于c++多态的实例代码为例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//code number: 001</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> width, height;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Shape</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>)<br>    &#123;<br>        width = a;<br>        height = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">Shape</span>(a, b) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> (width * height); <br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Triangle</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">Shape</span>(a, b) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> (width * height / <span class="hljs-number">2</span>); <br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 程序的主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>    Shape *shape;<br>    <span class="hljs-function">Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">7</span>)</span></span>;<br>    <span class="hljs-function">Triangle  <span class="hljs-title">tri</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 存储矩形的地址</span><br>shape = &amp;rec;<br><span class="hljs-comment">// 调用矩形的求面积函数 area</span><br>shape-&gt;<span class="hljs-built_in">area</span>();<br><br><span class="hljs-comment">// 存储三角形的地址</span><br>shape = &amp;tri;<br><span class="hljs-comment">// 调用三角形的求面积函数 area</span><br>shape-&gt;<span class="hljs-built_in">area</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该代码编译完成之后, 在ida中反编译的结果如下:  </p><p><img src="/4Cc3.github.io/images/pasted-36.png" alt="IDA反编译的伪代码">  </p><p>可以看到, 其中圈出来的部分v5 v4分别就是源代码中声明的变量的指针, 在调用成员函数时, 函数的第一项参数都是指向实例化后的对象的指针。 </p><h3 id="2-如何理解多态"><a href="#2-如何理解多态" class="headerlink" title="2. 如何理解多态"></a>2. 如何理解多态</h3><p>在c++中存在多态的概念, 此处还是以code 001为例, 当我们编译code 001时, 会发现其输出为  </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Parent class area :<br>Parent class area :<br></code></pre></td></tr></table></figure><p>&emsp;这并不是我们期望的输出, 我们的期望输出是:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Rectangle class area :<br>Triangle class area :<br></code></pre></td></tr></table></figure><p>&emsp;这种情况下, 就需要使用到c++中的多态概念, 即:相同名称行使不同功能。<br>&emsp;那么这种情况是怎么发生的呢？ 这里就需要理解两个概念 <strong>早绑定</strong> 和<strong>延迟绑定</strong>。<br><br>&emsp;首先， 绑定的概念是将符号变更为地址， 那么code 001 在编译时，其就会将里面的函数符号更换为地址，因为shape是一个已经声明过的变量，所以编译器会自动推理其类型， 为后面该变量所调用的成员函数进行绑定，那么此时绑定的函数都是Shape这个类的成员函数，因此所有的area函数都将是Shape这个类中的函数。<br>&emsp;如果为成员函数添加了virtual关键字，那么其就会通过虚表进行延后绑定。</p><h3 id="3-虚函数和虚表"><a href="#3-虚函数和虚表" class="headerlink" title="3. 虚函数和虚表"></a>3. 虚函数和虚表</h3><p>&emsp;虚函数在c++中实现多态。编译器在编译源代码时，编译器会为每一个包含虚函数的类生成一个表，其中包含<strong>指向每一个虚函数的指针</strong>。该表就叫虚表(vtable)。除此之外，编译器会为每一个类添加一个额外的成员变量，成为虚表指针(vtable pointer), 该指针会在适当的时候（一般是在运行创建对象的实例时）指向虚表，并且其是类的第一个成员变量。拿以下程序为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//code number: 002</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func5</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>&emsp;在上述程序中,B是A的一个子类, B中有5个虚函数(其中func1是A中的函数, 在B中对其进行了重构,并且B中多了一个函数func5, 所以B总共有5个虚函数)同时，A中存在一个纯虚函数，这就说明func1必须这种子类中进行重写，否则无法创建B的实例。<br>&emsp;在上面的程序中，看起来似乎A中存在两个数据成员，B有三个数据成员，实际上A有三个，B有四个， 因为其中包含一个虚表指针，虚表指针是两个类的第一个数据成员， 是编译器添加上去的<br><img src="/4Cc3.github.io/images/pasted-35.png" alt="虚表布局"><br>&emsp;像上面的布局，虚表有两个，分别是class A的和class B的，由于B中对func1和func5进行了重写, 所以B的虚表中的func1和func5都是B的函数地址,而其它没有在b中重写的函数则直接引用A的函数地址。<br>由于没有对纯虚函数func1进行实现,所以A的虚表中并没有func1的地址, 此时, 编译器会插入一个处理错误的函数的地址, 名为purecall, 这个函数理论上不会被调用, 其会令程序终止运行。  </p><p><img src="/4Cc3.github.io/images/pasted-37.png" alt="示例代码">  </p><p>对于上述代码, 调用了一个名为vfunc3的虚函数, 由于声明时声明的对象是A类型的, 但是实际上对象是B类型的对象, 所以在调用函数vfunc3时应该也要调用B对象的func3, 那么此时编译器就会使用虚表机制。</p><p>首先要将第虚表指针读出（结构体的第一个参数， 即为1处的eax），然后根据edx+8（即为寻址）来找到vfunc3的地址，然后再执行  </p><p>那么根据前面的代码，可以定义以下结构体  </p><p><img src="/4Cc3.github.io/images/pasted-38.png" alt="自定义结构体">  </p><p>此时, 再将虚表引用操作重新格式化后就会变成<code>mov eax, [edx+B_vtable.vfunc3]</code>  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA中创建结构体</title>
    <link href="/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h2 id="IDA中的结构体"><a href="#IDA中的结构体" class="headerlink" title="IDA中的结构体"></a>IDA中的结构体</h2><p>在IDA中, 遇见的结构体有以下四种情况:全局变量的结构体(定义在全局的变量), 创建在栈上的结构体(局部变量), 创建在堆上的结构体(使用malloc函数分配空间的指针), 结构体数组。  </p><p>*<br>对于声明在全局的结构体，编译器在编译时可以计算出每个成员的地址，不必进行任何计算， 所以声明在全局的结构题在反编译时看起来与没有声明结构体是一样的，乍一看很像一堆全局变量。  </p><ul><li><p>对于分配在栈上的结构体， 访问其成员变量页不需要任何计算， 编译器可以直接访问到每个字段的相对偏移量， 在这种情况下， 乍一看很像一堆局部变量</p></li><li><p>分配在堆上的结构体，就是先声明一个该结构体的指针， 然后在通过malloc函数为其分配空间，这种东西就没有办法通过在ida中创建结构体来恢复其在程序中应用的符号了，只能通过观察其在栈堆中的分配和操作来理解该结构体  </p></li><li><p>结构体数组唯一要注意的点是分配在堆上的结构体数组，此时malloc的参数可能是结构体大小的某一个倍数，而不是整个结构体的大小</p></li></ul><h2 id="创建IDA结构体"><a href="#创建IDA结构体" class="headerlink" title="创建IDA结构体"></a>创建IDA结构体</h2><p>在view -&gt; open subviews -&gt; structures中可以打开结构体窗口, 其中标蓝的是ida找到的结构体, 下图中框起来的是IDA告诉你,你可以执行的操作的快捷键。    </p><p><img src="/4Cc3.github.io/images/pasted-31.png" alt="IDA中的结体窗口"></p><p>同样，在view -&gt; open subviews -&gt; local types中就可以打开已经存在的变量类型， 如果你在suructers窗口中创建了结构体，那么就可以在本窗口中找到。选中需要编辑的变量类型， 按右键-&gt; edit(快捷键ctrl + E)就可以在本窗口中按照c语言风格来声明结构体中的成员变量了。  </p><p><img src="/4Cc3.github.io/images/pasted-32.png" alt="编辑结构体"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA中的数组</title>
    <link href="/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <url>/4Cc3.github.io/2024/02/23/IDA%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="在IDA中的数据类型"><a href="#在IDA中的数据类型" class="headerlink" title="在IDA中的数据类型"></a>在IDA中的数据类型</h2><p>数组是最简单的复合数据结构, 传统意义的数组是包含同一数据类型的连续元素组成的内存块, 也就是说, 数组实际上就是一段内存块的集合。 </p><p>而在c语言中，我们都熟知的一个东西就是数据类型， 而在计算机底层的概念中，数据类型是一个抽象的概念， 其本质是对一段内存布局中读写数据的长度。  </p><p>举例来说， 对于c语言中的int类型，其在x86中的长度是四个字节，也就是说计算机如果想读取一个int类型的数据，就要连续的读取四个字节才能正确的表示一个int类型的数  </p><p><img src="/4Cc3.github.io/images/pasted-24.png" alt="内存中存储一个int变量">  </p><p>如图所示, 如果在c语言中声明 <em>int a&#x3D;1</em>, 那么在程序编译完成后就会按照上图的形式存储。  </p><p>显然，ida并没有正确识别出其数据类型，这是因为编译器剥离了符号，但是经验丰富的逆向工程师是能够识别出这个变量实际上是一个32位整数。  </p><p>因此，逆向工程师会选择选中该数据，按快捷键d来改变其数据类型，对于那些更加了解ida的逆向工程师来说，他们可能更加乐意在option -&gt; set up datatypes(快捷键Alt + D) 中更改数据类型。</p><h2 id="在IDA中创建数组"><a href="#在IDA中创建数组" class="headerlink" title="在IDA中创建数组"></a>在IDA中创建数组</h2><p>在IDA中，你可以在Edit -&gt; Array中创建数组。在IDA中创建数组的默认大小是根据创建数组的第一个元素的长度决定的，例如创建数组的第一个元素的长度是4字节，那么之后所有的元素长度都是4字节，所以更改好第一个元素的长度很重要，其次就是要填好Array Size，这个代表数组的长度是多少，有几个元素这里就填几  </p><p><img src="/4Cc3.github.io/images/pasted-25.png" alt="IDA创建数组对话框">  </p><p>其中有几个选项这里简单介绍一下  </p><ul><li><p>Array Size: 创建数组的长度  </p></li><li><p>Item on a line: 一行显示的数组的长度</p></li><li><p>Element print width: 打印数组时的宽度, 这里指的是显示的宽度, 指定宽度后数据将在指定范围内显示  </p></li><li><p>use “dup” construct: 是否使用dup将重复的数据折叠  </p></li><li><p>signed element : 是否使用有符号元素  </p></li><li><p>display index： 该选项会在伪代码窗口中将元素按照数组的形式显示</p></li></ul><p>这里创建数组时需要自己对反编译的结果进行识别, <strong>gcc编译器在编译时, 如果一个数组并没有过用变量访问数组中的元素时（例如a[i]这种访问方式，只用过a[1]这种常量当访问下标）, 编译器就会对其进行优化, 使得ida无法正确识别出这一串数据是一个数组, 所以需要自己创建数组</strong>, 例如以下程序:  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int a<span class="hljs-comment">[17]</span>=&#123;1,2,3,4&#125;;<br>int main()&#123;<br>a<span class="hljs-comment">[0]</span>+=11;<br>a<span class="hljs-comment">[2]</span>+=12;<br>a<span class="hljs-comment">[17]</span>=18;<br>a<span class="hljs-comment">[16]</span>=20;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序在编译完成并剥离符号表后, 会变成下面这个样子  </p><p><img src="/4Cc3.github.io/images/pasted-27.png" alt="IDA伪代码视图"></p><p><img src="/4Cc3.github.io/images/pasted-28.png" alt="IDA反汇编视图"></p><p>这里选中第一个元素,将其转化位dd(第二个d是double word的意思), 计算下数组长度(源代码中是a[17], 这里数组长度就填18), 然后创建数组, 就可以生成一个数组了。</p><p>可以看到, 在反汇编窗口中并不能直观的看出这段数据是一个数组, 并且还多了一些东西, 初步估计是编辑器为了防止内存溢出设置的缓冲区域  </p><p><img src="/4Cc3.github.io/images/pasted-29.png" alt="编译完成后,数组前后会多出20h个字节的区域"></p><p><img src="/4Cc3.github.io/images/pasted-30.png" alt="成功创建数组后的ida中伪代码视图"></p><p>至此, 就成功创建了一个数组, 后面再进行逆向分析都会容易很多。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手册: IDA使用</title>
    <link href="/4Cc3.github.io/2024/02/20/%E6%89%8B%E5%86%8C-IDA%E4%BD%BF%E7%94%A8/"/>
    <url>/4Cc3.github.io/2024/02/20/%E6%89%8B%E5%86%8C-IDA%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>文本搜索: Search -&gt; Text(Alt + T)启动文本搜索，可以用于搜索一个完整的词，按ctfl + T就可以重复前一项搜索，匹配下一项结果。  </p><p>二进制搜索： serach -&gt; squence of bytes(ALT + B)即可启动二进制搜索。其可以搜索一个二进制字节序列，以空格分隔，按ctfl + T就可以重复前一项搜索，匹配下一项结果。如果想要搜索内嵌字符串（即十六进制种ASCII字符串），则需要讲搜索字符串用引号括起来 。如果想要搜索操作码序列而不是ASCII文本时，记得勾选Case sensitive，不然会出现匹配到无关结果。</p><p>函数: 从Edit -&gt; function 中即可进行创建函数, 删除函数等操作, 按快捷键c可以将一段十六机制数识别为代码</p><p>数组: 在Edit -&gt; Array中打开创建数组对话框, 如果指定位置的第一个数据项已经被定义, 那么直接按右键,在弹出的上下文菜单中就会显示Array选项, 创建的数组的元素的类型由第一个元素的类型决定  </p><h2 id="ida显示设置"><a href="#ida显示设置" class="headerlink" title="ida显示设置:##"></a>ida显示设置:##</h2><ul><li><p>栈指针: general -&gt; option -&gt;disassembly-&gt;勾选stack pointer 即可在ida中显示函数中的栈指针的相对值<br><img src="/4Cc3.github.io/images/pasted-21.png" alt="栈指针开启后的效果">  </p></li><li><p>一行中显示字节码的数量<br><img src="/4Cc3.github.io/images/pasted-22.png" alt="选择一行中可显示的字节码数量"> </p></li><li><p>更改数据类型<br>options -&gt; setup data types  中打开对话框<br><img src="/4Cc3.github.io/images/pasted-23.png" alt="指定数据大小"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈帧</title>
    <link href="/4Cc3.github.io/2024/02/20/%E6%A0%88%E5%B8%A7/"/>
    <url>/4Cc3.github.io/2024/02/20/%E6%A0%88%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<p>以下面的程序为例  </p><p><img src="/4Cc3.github.io/images/pasted-16.png" alt="示例函数"></p><p>demo_stackframe函数调用了一个bar函数, 并且demo_stackframe函数自身还包含三个参数和几个局部变量, 那么在调用demo_stackframe函数时就会产生一个栈帧, 该栈帧长下面这个样子  </p><p><img src="/4Cc3.github.io/images/pasted-17.png" alt="基于ESP的栈帧">  </p><p>这个是基于ESP的栈帧, 它包含了abc三个参数(在调用demo_stackframe时产生的), 一个eip,(用于确定demo_stackframe返回时的地址)四个局部变量。那么对于该栈帧来说， 想要调用其中一个局部变量就可以使用偏移的方式来调用，例如[esp+4]就代表调用y这个变量 ，但是基于ESP的栈帧有个坏处， 那就是在demo_stackframe中调用函数bar的时候， 会用到push来将bar函数需要用到的函数压入栈中，而push又会改变esp的位置， 所以会产生一些混乱的情况 ，例如：</p><p><img src="/4Cc3.github.io/images/pasted-18.png" alt="示例代码">  </p><p>上面的1 和 2 处虽然都是esp+4，但是却代表不同参数，所以说不是很好看，为了解决这个问题， x86提供了一个名为EBP的寄存器专门用来存栈帧指针， 啥意思呢？  </p><p>简单来说， EBP这个寄存器中存储的是进入到被调用函数时，ESP的位置。</p><p><img src="/4Cc3.github.io/images/pasted-19.png" alt="基于EBP的栈帧">  </p><p>像上面这个图， 相较于基于ESP的栈帧多了一个saved ebp， 这个是因为stdcall和cdecl都要求函数只能动EAX，ECX和EDX，别的寄存器都不能动，（因此其它寄存器都被称为被保护寄存器）<br>所以要想使用EBX，就必须先把EBX的值存下来，然后在用完EBX之后再把值存回去</p><p>在使用基于EBP的栈帧时，调用者需要执行以下代码  </p><p><img src="/4Cc3.github.io/images/pasted-20.png" alt="示例代码">  </p><p>也就是说，EBP指向的其实就是自己原先的值的位置，而在EBP之下的东西（栈是向下生长的）都是局部变量，或者是其它被调用函数的东西，我们不是很关心， 我们只需要知道， 在本函数执行完毕时，直接将ESP放到EBP的位置上就可以释放所有局部变量， 并且基于EBP的栈帧的所有变量的偏移值都是不会变的。</p><p>执行完demo_stackframe毕之后， 只需要 </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><span class="hljs-comment">;直接清除掉了所有局部变量</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span> <span class="hljs-comment">;恢复ebp最开始的值</span><br><span class="hljs-keyword">ret</span>     <span class="hljs-comment">;回到调用demo_stackframe的那个call语句的下面那一条语句, 等价于弹出栈中的saved eip, 然后跳转到eip的位置</span><br></code></pre></td></tr></table></figure><p>当然, 上述指令被x86简化了, 其提供了一个leave指令 </p><pre><code class="hljs">leaveret</code></pre><p>leave指令执行将esp释放到栈帧最开始的位置(也就是ebp指的位置),以达到清除全部临时变量的效果, 然后再恢复ebp最开始的值。  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调用约定</title>
    <link href="/4Cc3.github.io/2024/02/20/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/4Cc3.github.io/2024/02/20/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>调用约定是指程序在调用函数时的规则，例如参数入栈的顺序，返回值的位置等。  </p><h2 id="C调用约定（-cdecl）"><a href="#C调用约定（-cdecl）" class="headerlink" title="C调用约定（_cdecl）"></a>C调用约定（_cdecl）</h2><p>_cdecl是x86体系中c编译器使用的默认调用约定，其要求函数参数按照从右往左的顺序入栈， 这样就能使第一个参数永远放在栈顶  </p><p> 同时，该约定还要求函数的参数如果放在了栈中， 那么就需要由调用者（caller）函数将参数压栈，并且在返回时将栈指针恢复（即恢复esp的位置）  </p><p>例如：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">call</span> func<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">16</span><br><br></code></pre></td></tr></table></figure><p>当然也有不改变esp的情况， 例如  </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">12</span>],<span class="hljs-number">4</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">8</span>],<span class="hljs-number">3</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>],<span class="hljs-number">2</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>],<span class="hljs-number">1</span><br><span class="hljs-keyword">call</span> func<br><br></code></pre></td></tr></table></figure><p>像上面的函数没有改变esp的位置, 所以不需要再次调整esp, 可以直接执行下一条指令  </p><h2 id="标准调用约定-stdcall"><a href="#标准调用约定-stdcall" class="headerlink" title="标准调用约定(_stdcall)"></a>标准调用约定(_stdcall)</h2><p>该约定为微软定义, 其参数的入栈顺序也为从右到左, 但是该约定在函数结束执行时, 由被调用者(callee)函数删除栈中的参数。这种方式相对于cdecl来说， 被调用者函数如果接受的是一个变长参数， 那么被调用函数就不知道自己接受的参数到底有多长，所以stdcall不支持变长参数的函数（例如printf）</p><p>x86编译器会使用ret指令的一种特殊形式来实现上述过程， 即为 <strong>ret [imm]</strong> (imm为一个立即数) 该指令在返回时（回到调用本函数的call指令下面一条指令）时会顺便给栈指针加上这个立即数， 即为从栈中释放imm个字节的空间</p><p>书上说这种调用约定的优点是不需要通过代码从栈中清除参数， 因此该调用约定会稍微快一些（实际上我感觉作用微乎其微， 除非能够在硬件层面上ret imm这种指令要比add这个指令快）  </p><h2 id="x86-fastcall约定"><a href="#x86-fastcall约定" class="headerlink" title="x86 fastcall约定"></a>x86 fastcall约定</h2><p>fastcall是stdcall的一个变体， 它的意思是向寄存器传参，而不是向栈传参，当然学过计算机系统的小伙伴会知道， 程序一般是不把参数放在栈里的， 大多数函数都是将参数放在寄存器中， 只有参数大于七个的时候程序才会考虑优化， 将参数放在栈中。</p><p>而本约定与上述情况类似， 但是fastcall约定函数向寄存器最多传递两个参数， 并且将前两个参数分别放在ECX和EDX寄存器中， 而其他的参数则更stdcall一样， 将参数从右到左压入栈中，并且由被调用者清除参数。</p><h2 id="C-调用约定"><a href="#C-调用约定" class="headerlink" title="C++调用约定"></a>C++调用约定</h2><p>C++有类这么个东西， 它会需要用到this指针（this指向实例化过后的对象）， 如果一个类中包含一个成员函数，并且该函数为非静态成员函数（public的），那么实例化过后的对象在调用这个函数时， this指针就应该指向这个实例化过后的对象， 并且这个this指针需要由调用方提供给被调用方（因为被调用的函数并不知道何时会出现该类的实例化对象）  </p><p>所以如何传递this指针就成为一个问题， C++标准并未规定如何传递this， 所以不太编译器传递this的方式不同</p><p>msC++提供一个 <strong>thiscall</strong>约定，它讲this指针传递到ECX中， 并且由被调用函数清除栈中参数。  </p><p>GNU g++ 将this看成所有非静态成员函数的第一个隐含参数， 其它方面与cdecl相同 ， 因此， 对使用g++编译的代码来说， this永远是放在栈顶的， 并且由调用者删除栈中参数  </p><p>其它调用约定还有很多， 此处不再赘述。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验：RC4算法</title>
    <link href="/4Cc3.github.io/2024/02/18/%E5%AE%9E%E9%AA%8C%EF%BC%9ARC4%E7%AE%97%E6%B3%95/"/>
    <url>/4Cc3.github.io/2024/02/18/%E5%AE%9E%E9%AA%8C%EF%BC%9ARC4%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="RC4算法原理"><a href="#RC4算法原理" class="headerlink" title="RC4算法原理"></a>RC4算法原理</h2><p>RC4算法的加密部分就是单纯的将一个密钥流与明文逐字节的进行一次异或，其真正关键的地方在于如何生成密钥流  </p><p>在生成密钥流的时候用到了两个算法， 分别是key-scheduleing algorithm（KSA）算法和pseudo-random generation algorithm（PRGA），而这两个算法则是RC4的核心 , 接下来将以长度为256的明文为例子</p><hr><h2 id="KSA"><a href="#KSA" class="headerlink" title="KSA"></a>KSA</h2><p>ksa首先会初始化一个S盒， 初始化的过程非常的简单， 只需要将S盒按照1-256依次赋值即可  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">255</span>;i++)&#123;<br>S[i]=i;<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><p>然后，建立一个临时数组， 称为T盒，大小与S盒相同，用原始密钥对T进行循环填充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">255</span>;i++)&#123;<br>           T[i]=K[i % keylen];<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><p>此时，初始化工作已经完成，接下来将进行置换操作  ，对S盒中的元素的位置进行如下交换操作  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>&#123;<br>   j = (j + S[i] + T[i]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-built_in">swap</span>(S[i], S[j]);<br>&#125;<br>   <br></code></pre></td></tr></table></figure><hr><h2 id="PRGA"><a href="#PRGA" class="headerlink" title="PRGA"></a>PRGA</h2><p>建立S盒之后，S盒仍然是会发生变化的， 在PRGA中每生成一个字节的密钥流， 就会打乱一次S盒  ,具体步骤如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化i，j为0</span><br><span class="hljs-type">int</span> cnt=<span class="hljs-number">256</span>;<br><span class="hljs-type">int</span> key[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">while</span>(cnt--)<br>&#123;<br>    <span class="hljs-comment">//i自增1</span><br>    i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//j自增S[i]</span><br>    j = (j + S[i]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//交换，打乱S表</span><br>    <span class="hljs-built_in">swap</span>(S[i], S[j]);<br>    <span class="hljs-comment">//使用变量t保存输出S表的下标</span><br>    t = (S[i] + S[j]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//存储一字节的密钥流序列k</span><br>    key[i]=S[t];<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说,RC4还是一个相当简单的算法的, 其核心思想为生成密钥流,只要能找到对应生成密钥流的逻辑就能轻松的解出题目,<br>只要知道RC4中KSA盒PRGA算法的细节,再找到初始密钥k, 就能自己生成一个密钥流, 对密文进行解密</p><p>最后给出一份实验代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> char unsigned char <span class="hljs-comment">//这里记得使用无符号的char, 否则在置换密钥流的时候会出现段错误(访问负数下标)</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string dat=<span class="hljs-string">&quot;welcome to join the SUDA Security and the ATS-Team!!!&quot;</span>;<span class="hljs-comment">//length=53</span><br><span class="hljs-type">int</span> dataLen=<span class="hljs-number">53</span>;<br>string key=<span class="hljs-string">&quot;Sud@s3curi3ty&quot;</span>;<br><span class="hljs-type">int</span> keylength=<span class="hljs-number">13</span>;<br><span class="hljs-type">char</span> S[<span class="hljs-number">256</span>],T[<span class="hljs-number">256</span>];<br><span class="hljs-type">char</span> keyStream[<span class="hljs-number">256</span>];<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)&#123;<br>S[i]=i;<br>T[i]=key[i%keylength];<br>&#125;<br><br>j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)&#123;<br>j=(j+S[i]+T[i])% <span class="hljs-number">256</span>;<br><span class="hljs-built_in">swap</span>(S[i],S[j]);<br>&#125;<br><br>j=<span class="hljs-number">0</span>;<br>i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;dataLen;cnt++)&#123;<br><br>i=(i+<span class="hljs-number">1</span>)%<span class="hljs-number">256</span>;<br>j=(j+S[i])%<span class="hljs-number">256</span>;<br><br><span class="hljs-built_in">swap</span>(S[i],S[j]);<br>tmp=(S[i]+S[j])%<span class="hljs-number">256</span>;<br>keyStream[cnt]=S[tmp];<br><br><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;dataLen;i++)&#123;<br><span class="hljs-type">int</span> a=(<span class="hljs-type">int</span>)(dat[i]);<br><span class="hljs-type">int</span> b=(<span class="hljs-type">int</span>)(keyStream[i]);<br><br>cout&lt;&lt;(a^b)&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>加密算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于逆向中遇到的变量大小的问题</title>
    <link href="/4Cc3.github.io/2024/02/13/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <url>/4Cc3.github.io/2024/02/13/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>首先, 计算机中最基本的单位是bit, 一个bit只有0或者1两种状态  </p><p>而在做逆向的过程中最基本的单位是一个byte, 也就是两个十六进制数, 一个byte最大可以表示的整数为255(也就是FF)。 有些同学会发现， ASCII码表的长度刚好也是256， 其刚好是一个byte可表示的全部范围。</p><p>在x86架构中，偏移量一般都是用十六进制表示的，并且每一个数字对应的就是一个byte， 例如： [rsp+0h] 和 [rsp+4h]</p><p><img src="/4Cc3.github.io/images/pasted-11.png" alt="upload successful"></p><p> 这两个都是表示一个取值， 分别对应rsp+4h和rsp+0h位置的值。 而在观察后发现， 这两个变量存储的空间上刚好差了4h， 这里4h代表的就是4 byte， 也就是说， 这两个变量如果类型相同的话， 可以推断出两个变量的长度就为4 byte。 </p><p>而在之前的博文中提到过，x86架构下规定word的长度为2 byte是定死不变的， 所以这里4 byte刚好就是DWORD， 也就是一个整形的长度 ， 即为一个32 bit的数， 对应的就是8位十六进制数（其最大表示为FFFF FFFF） ，此处ida已经帮我们标注好了，该变量是一个无符号整形。</p><p>再通过观察可以发现这两个变量其实是相邻的，那么假如此时有一个调用为v4[1] , 那么这个语句就代表以v4的长度，取其相邻的下一个数。意思就是v4是一个DWORD， 那么v4[1]就是在v4的地址上再加4个byte ，（因为DWORD的长度是4byte），那么v4[1]代表的其实就是v5这个变量。  </p><p>在做逆向的过程中，有些时候还会遇到结构体的问题， 在修复结构体时也要灵活识别每个成员变量的长度， 推断其属于哪种类型，这里简单给出一些类型对应的长度:  </p><table><thead><tr><th>类型</th><th>二进制长度</th><th>十六进制长度</th><th>十六进制最大表示数</th></tr></thead><tbody><tr><td>char</td><td>8位</td><td>2位</td><td>FF</td></tr><tr><td>int、unsigned int、DWORD</td><td>32位</td><td>8位</td><td>FFFF FFFF</td></tr><tr><td>指针（32位程序）</td><td>32位</td><td>4位</td><td>FFFF FFFF</td></tr><tr><td>指针（64位程序）</td><td>64位</td><td>16位</td><td>FFFF FFFF FFFF FFFF</td></tr><tr><td>long long、 QWORD</td><td>64位</td><td>16位</td><td>FFFF FFFF FFFF FFFF</td></tr></tbody></table><p>这里给出的十六进制最大表示数的意义是如下：</p><p><img src="/4Cc3.github.io/images/pasted-15.png" alt="upload successful">  </p><p>方便大家用计算器测试， 因为只有用最大表示数才能直观的看出某一个长度的变量到底是多少位</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验: 从应用程序中加载和链接共享库</title>
    <link href="/4Cc3.github.io/2024/02/09/%E5%AE%9E%E9%AA%8C-%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
    <url>/4Cc3.github.io/2024/02/09/%E5%AE%9E%E9%AA%8C-%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><strong>本实验使用linux系统中自带的库函数实现在程序中加载共享库</strong></p><p>一般在程序中不会依赖这种方法实现共享库的加载, 更多的情况是在编译阶段通过引入头文件的方式, 直接将需要引入的符号直接在编译阶段引入, 而本实验实现通过一个文件路径和符号名称实现在任意一个程序中加载共享库  </p><p>本实验将会使用到的函数如下:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br>   <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flag)</span></span>;<br>   <span class="hljs-comment">// 若成功返回指向句柄的指针,否则返回NULL, filename为一个路径, flag为可选项, 一般使用RTLD_LAZY即可</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dlsym</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle , <span class="hljs-type">char</span> *symbol)</span></span>; <br>   <span class="hljs-comment">//若成功则返回指向符号的指针, 否则返回NULL, handle为已经打开的共享库的句柄, symbol为要使用的符号</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlclose</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle)</span></span>;<br>   <span class="hljs-comment">// 成功返回0 出错返回-1;</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">dlerror</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>   <span class="hljs-comment">//如果有调用失败的情况则返回出错信息,否则返回NULL  </span><br>   <br></code></pre></td></tr></table></figure><p>首先对以下程序进行编译</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-type">int</span> addcnt;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addvec</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y, <span class="hljs-type">int</span> *z,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        addcnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>                z[i]=x[i]+y[i];<br><br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>  使用如下指令编译共享库文件:  </p><pre><code class="hljs">  ❯ gcc -share -fpic addvec.c -o libvector.so  </code></pre><p>   -share选项将会使用动态库, -fpic参数是告诉编辑器产生于位置无关的代码(Position-Independent Code)  </p><p>   然后将libvector.so移动到同目录下名为lib的文件夹下, 此处是为了体现dlopen函数中的filename参数是文件路径</p><p>在mian.c中写如下代码  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><br><br>       <span class="hljs-type">void</span> *handle;<br>       <span class="hljs-built_in">void</span>(*addvec)(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>*,<span class="hljs-type">int</span> * ,<span class="hljs-type">int</span>  );<br>       <span class="hljs-type">char</span> *error;<br><br>       handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;./lib/libvector.so&quot;</span>,RTLD_LAZY);<br><br>       <span class="hljs-keyword">if</span>(!handle)&#123;<br>               <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">dlerror</span>());<br>               <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>       &#125;<br><br><br>       addvec = <span class="hljs-built_in">dlsym</span>(handle , <span class="hljs-string">&quot;addvec&quot;</span>);<br><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dlerror</span>()!=<span class="hljs-literal">NULL</span>)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;failed&quot;</span>);<br>               <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>       &#125;<br><br><br>       <span class="hljs-built_in">addvec</span>(x,y,z,<span class="hljs-number">2</span>);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z=[%d,%d]\n&quot;</span>,z[<span class="hljs-number">0</span>],z[<span class="hljs-number">1</span>]);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;execute successfully\n&quot;</span>);<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以编译main.c了</p><pre><code class="hljs">❯ gcc main.c   </code></pre><p> 此时在同名目录下就会生成一个a.out 是一个可执行文件, 可以正常运行了  </p><pre><code class="hljs"> ❯ ./a.outz=[4,6]execute successfully</code></pre>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是动态库</title>
    <link href="/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <url>/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>动态库的全称是_”动态链接共享库”_  , 其是一个目标模块, 在运行和加载时可以加载到任意的内存地址, 并和一个在内存中的程序链接起来, 这个过程叫做 <em>动态链接(dynamic linking)</em>  , 其是由一个叫做 <em>动态链接器(dynamic linker)</em> 的程序来执行的。</p><p>在linux中动态库通常被叫做共享目标（shared object） 用.so作为后缀, 而在windows中叫做动态链接库, 用.dll做后缀  </p><p>动态链接库的工作原理如下:  </p><p><img src="/4Cc3.github.io/images/pasted-9.png" alt="动态链接库工作流程">  </p><p><em>此处的图片出自《深入理解计算机系统》，main2.c在本文中命名为main.c, prog21在本文中命名为prog</em></p><p>首先, 先由翻译器将main.c中的代码(以及其引入的头文件) 编译成obj文件, 其次再由链接器将so文件和obj文件链接起来, 在执行时, 加载器会根据链接时指定的<br>地址来加载so文件中的代码段 ,这个过程由动态链接器完成, 下面给出实验过程  </p><p><em>注意: 此时使用的代码与上一章””什么是静态库”中展示的代码相同</em>  </p><p>使用如下命令生成libvector.so文件</p><pre><code class="hljs">❯ gcc -shared -fpic -o libvector.so addvec.c multvec.c</code></pre><p>-shared选项代表生成一个共享目标文件(也叫动态库) , -fpic代表生成与位置无关的代码  (编译共享库时总是需要开启此选项)</p><p>随后, 将动态库链接到主程序中  </p><pre><code class="hljs">❯ gcc -o prog main.c ./libvector.so</code></pre><p>然后就成功生成了名为prog的可执行文件</p><p>动态链接器(ld-linux.so)的工作原理如下:  </p><ul><li>重定位libc.so的文本和数据到某个内存段  </li><li>重定位libvector.so</li><li>重定位porg中所有对libc.so和libvector.so定义的符号的引用</li></ul><p>最后动态链接器再将控制传递给应用</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是静态库</title>
    <link href="/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/4Cc3.github.io/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>静态库(static library)是编译系统的一种机制, 用以解决如下问题:  </p><ul><li>编译器如何向用户提供一些标准函数</li></ul><p>一种方式是将标准函数全部放到一个目标文件(object file)中, 但是这么做就需要用户每次编译时采用  </p><pre><code class="hljs">linux&gt; gcc main.c /usr/lib/libc.o   </code></pre><p>这种方法对程序员有适当的便利, 但是缺点是每次编译时都需要把整个目标文件全部拷贝到可执行文件中去, 会增大文件的体积  </p><p>其次, 对于标准函数的改变将会需要重新编译整个源文件, 费时费力。  </p><p>所以，静态库的概念被提出来，以解决上述问题。   </p><p>在静态库中， 不同的函数被放在不同的模块中，在连接时，连接器只复制被引用的目标模块，这样就减少了程序的占用空间。  </p><p>下面给出构造静态库和使用静态库的实验  </p><p><img src="/4Cc3.github.io/images/pasted-6.png" alt="addvec.c"></p><p><img src="/4Cc3.github.io/images/pasted-7.png" alt="mulvec.c"></p><p>使用如下指令编译  </p><pre><code class="hljs">❯ gcc -c addvec.c multvec.c</code></pre><p>这里的-c指令是在链接阶段停止, 只做预处理, 编译 ,汇编, 这会将程序编译成一个obj文件,在同目录下生成同名的.o文件   </p><p>编译好之后运行  </p><pre><code class="hljs">linux&gt; ar rcs libvector.a addvec.o mulvec.o  </code></pre><p>就可以生成一个名为libvector.a的静态链接库文件(a的意思是archive)</p><p>为了调用生成的库文件, 编写如下源程序<br><img src="/4Cc3.github.io/images/pasted-8.png" alt="upload successful"></p><p>然后在编译可执行文件时, 使用如下指令  </p><pre><code class="hljs">linux&gt; gcc -c main.c</code></pre><p>这个指令先生成一个关于main的目标文件, 但是此时并不进行连接, 也就是说无法执行</p><p>然后再执行以下指令</p><pre><code class="hljs">linux&gt; gcc -static -o prog main.o ./libevector.a</code></pre><p>-static参数告诉编译器, 连接器应该构建一个完全链接的可执行文件, 它可以直接加载到内存并运行, 此选项会禁用动态库, 也就是说会把动态库中的所有东西都编译出来, 一般编译出来的东西都很大</p><pre><code class="hljs">p.s:在linux环境下, 链接库文件的后缀为.a, 在windows平台下后缀通常为.lib </code></pre><p>总得来说, 先将自己写好的代码(addvec.c和multvec.c)编译为obj文件, 然后通过ar工具将可重定位文件链接为一个.a文件(静态链接库文件)  </p><p>在这里还涉及到一个隐式函数的问题, 在c语言中, 如果一个函数在引用时没有声明, 那么在编辑器使用它的时候会自动为其添加隐式声明, 在链接时寻找其符号</p><p>紧接着, main.c源文件在通过翻译器(cpp,ccl,as)的作用下, 生成一个main.o(可重定位目标文件), 然后再与libvector.a(我们自己构建的静态链接库), libc.a(GNU提供的标准库文件)链接, 生成一个完全链接的可执行目标文件  </p><p>在此过程中, 链接器不会使用multvec.o中的内容 , 因为程序没有引用multvec.o中的符号  </p><p>在使用静态链接库时, 一般需要把他们放在命令行的结尾, 并且根据依赖关系进行排序, 否则就可能会发生”undefined reference”的错误, 这种错误的发生与编辑器实现链接时的规则有关, 但是近代的gcc有没有改善这一问题暂时还不清楚, 有可能以后不会再遇到这种问题也说不定，这块的内容还没有做过实验</p><p>对于上述问题的解决方法, 可以用ar工具将多个.a文件再次合并为一个单独的.a文件</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符号和符号表</title>
    <link href="/4Cc3.github.io/2024/02/07/%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
    <url>/4Cc3.github.io/2024/02/07/%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>首先先讲一个知识: 在c语言中的static的作用为使符号成为模块内部的私有符号, 类似于c++和java中的private, 加了static的变量或函数则不可在外部模块中被访问。<br>而在后续的描述中，统一把单个执行某一种功能的c语言源文件称为“模块”</p><p>在符号表中有以下三种变量：  </p><ul><li>全局连接器符号（由本模块定义的并且能被其他模块引用的全局符号）， 对应非静态函数和全局变量  </li><li>外部符号（由其他模块定义并被本模块应用的全局符号）</li><li>局部符号（只被本模块定义和应用的符号）</li></ul><p>在.symtab段中的符号表不包括本地非静态变量的任何符号(局部变量), 因为他们是被存放在栈中的。  </p><p>但是如果局部变量被加了static属性，那么该变量会在.data段和.bss段中被分配一个空间, 并且在.symtab段中有唯一名字的本地连接器符号</p><p>符号表的条目定义如下, 使用readelf即可读到一个目标文件中的符号表</p><p><img src="/4Cc3.github.io/images/pasted-5.png" alt="upload successful"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF文件格式简述</title>
    <link href="/4Cc3.github.io/2024/02/06/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/4Cc3.github.io/2024/02/06/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="计算机编译可执行文件时的步骤"><a href="#计算机编译可执行文件时的步骤" class="headerlink" title="计算机编译可执行文件时的步骤"></a>计算机编译可执行文件时的步骤</h3><p> 在计算机编译可执行文件时主要分为以下几个步骤:  </p><ol><li>对于一个或多个(在定义实现的情况下是多个源文件)c语言编写的ascii源文件,先由预处理器将头文件,宏定义等内容替换, 形成一个ascii码的中间文件: <strong>.i文件</strong>, 此时文本和编写的源代码差别不是很大  </li><li>编译器(ccl)将.i文件翻译成一个ascii的汇编语言文件: <strong>.s文件</strong> ,里面是可读的汇编指令</li><li>汇编器(as)将.s文件翻译成一个或多个可重定位目标文件<br>  <strong>(relocatable object file)</strong> : <strong>.o文件</strong> , 此时以及将ascii文件编译为hex文件, 其文件格式符合elf文件格式  </li><li>连接器(ld)将各个可重定位目标文件(后面简称obj文件)和一些必要的系统目录组合, 创建一个可执行目标文件 <strong>(executable object file )</strong></li></ol><p>此时, 一个程序就被编译好了, 在shell中直接输入文件名即可运行, shell在加载的过程中会使用一个名为loader的函数, 它将可执行文件中的代码数据复制到内存, 然后将控制权转移到函数的开头 </p><p>对于目标文件(object file) 有三种形式, 分别是</p><ul><li><strong>可重定位目标文件(relocatable object file )</strong>: 可以在编译时于其他obj文件合并</li><li><strong>可执行目标文件(executable object file)</strong>:  可直接被复制到内存并执行</li><li><strong>共享目标文件(shared  object file)</strong>:  lib或者dll等文件</li></ul><p>ELF的全称为(Executable and Linkable Format), 无论是那种可执行文件的格式, 其基本概念是相似的</p><hr><br><h3 id="ELF-可重定位目标文件的格式"><a href="#ELF-可重定位目标文件的格式" class="headerlink" title="ELF 可重定位目标文件的格式"></a>ELF 可重定位目标文件的格式</h3><p>ELF header以十六字节的序列开始，该序列描述了生成文件的word长度和字节顺序。<br>而其剩下的部分包含各类信息，其包括  </p><p><strong>ELF头的大小，目标文件的类型，（可执行，共享，可重定位），机器类型（x86-64）,section header table的文件偏移，section header table的条目数量和大小等</strong>   </p><p>不同节的位置和大小都是由section header table描述的，其中目标文件中每一个字节都有一个固定大小的entry。  </p><p><img src="/4Cc3.github.io/images/pasted-1.png" alt="upload successful">  </p><p>在section header table和elf文件头中间的就是节， 一般elf文件包含以下几个节  </p><table><thead><tr><th align="left">段   &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</th><th align="left">存储内容</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">已经编译的机器代码</td></tr><tr><td align="left">.rodate</td><td align="left">一些只读数据, 通常是字符串或者是一些常量</td></tr><tr><td align="left">.data</td><td align="left">已经初始化的全局变量和静态c变量,以及所有被初始化为0的全局变量或静态变量</td></tr><tr><td align="left">.bss</td><td align="left">未初始化的全局变量和静态变量,  这个节在obj文件中不占用实际的空间, 它仅仅是一个占位符</td></tr><tr><td align="left">.symtab</td><td align="left">一个符号表,它存放在程序中定义和引用的函数和全局变量的信息, 也就是符号表</td></tr><tr><td align="left">.rel.text</td><td align="left">.text节中的位置的列表</td></tr><tr><td align="left">.rel.data</td><td align="left">被模块引用或定义的所有全局变量的重定位信息</td></tr><tr><td align="left">.debug</td><td align="left">调试符号表, 只有以-g选项编译程序时才会得到这张表</td></tr><tr><td align="left">.line</td><td align="left">原始c程序中的行号和.text节中机器指令之间的映射, 只有以-g编译程序时才会得到这张表</td></tr><tr><td align="left">.strtab</td><td align="left">字符串表</td></tr></tbody></table><p>其中后五条见的都比较少, 尤其是在逆向工程中一般都是不含这些信息的  </p><pre><code class="hljs">p.s:.bss段的全称叫(Block Storage Start) 其用于表示未初始化的数据</code></pre><p>除此之外，有些时候还会见到.init_array和.init这样的节，其主要用在so文件中，用来对elf文件进行初始化,对于init_array的设置方法如下:</p><p>在GNU C中 可以在函数后面添加以下语句:  </p><pre><code class="hljs">__attribute__((constructor));__attribute__((destructor));  </code></pre><p> 这个语句可以用来给函数设置属性, 变量属性, 类型属性<br> 而其中的constructor和destructor为构造函数的属性, 这类函数将会在main函数之前被执行, 可见在加了该属性的函数在ida中则会在init_array段被调用</p><p><img src="/4Cc3.github.io/images/pasted-2.png" alt="upload successful"></p><p><img src="/4Cc3.github.io/images/pasted-3.png" alt="upload successful">  </p><p>在windows平台下，该语法仍然成立</p><p>在constructor中还可以携带参数， 例如  </p><pre><code class="hljs">__attribute__((constructor(100))) void load_init();__attributr__((constructor(102))) void load_file();</code></pre><p>里面的参数代表执行的优先级</p><p>通过这种方法可以实现smc、加壳等加密反调试手法，具体的实验则会在后面的文章中具体展示  </p><p>而关于_<em>attribute_</em> 的相关用法 可以参考<a href="https://www.jianshu.com/p/c8bea3807527">该博客</a>   </p><p>关于其具体的用法在后续的文章中也会给出具体的实验(如果有时间的话做一下, 因为感觉这里面大多数的东西不是很重要)</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/4Cc3.github.io/2024/02/04/hello-world/"/>
    <url>/4Cc3.github.io/2024/02/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>我会在这里记录我的学习过程</p><p><img src="/4Cc3.github.io/images/%E6%8D%A3%E8%9B%8B%E7%8C%AB.gif#pic_center" alt="无敌导弹猫"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>word到底是什么?</title>
    <link href="/4Cc3.github.io/2024/02/03/x86%E5%AD%A6%E4%B9%A0/"/>
    <url>/4Cc3.github.io/2024/02/03/x86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>一直搞不清楚word到底是什么单位，在ida中也经常会见到DWORD和QWORD这些类型，在我的印象里word一直是两个byte组成的，但是又经常看到说word是根据cpu位数决定的，所以在这里写一篇文章记录一下学习探讨的过程  </p><p>首先，word这个单位是描述计算机进行数据处理的时候一次存取，加工，传送的数据长度，一般与寄存器的长度相同  </p><p>在32位机中1word是32bit<br>在64位机中1word是64bit<br>在16位机中1word是16bit  </p><p>而intel厂商为了可移植性，统一规定了1word为16bit<br>这也是为什么无论32bit的程序还是64bit的程序在ida反编译的结果中都是1 word对应2 byte</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
